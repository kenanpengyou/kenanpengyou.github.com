<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>acgtofe - 动漫与前端技术的综合博客</title>
 <link href="http://acgtofe.com/atom.xml" rel="self"/>
 <link href="http://acgtofe.com"/>
 <updated>2013-08-12T21:40:24+08:00</updated>
 <id>http://acgtofe.com</id>
 <author>
   <name>Liang Zhu</name>
   <email>kenanpengyou@gmail.com</email>
 </author>

 
 <entry>
   <title>写给初学者的javascript知识</title>
   <link href="http://acgtofe.com/posts/2013/07/javascript-for-beginners"/>
   <updated>2013-07-18T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/07/javascript-for-beginners</id>
   <content type="html">&lt;p&gt;最初学习javascript时，我还没有想到它是一门包含丰富内容的独立程序设计语言。和过去可以找到的很多javascript教程中描述的一样，我对它的看法就是它对应于web网页的行为层，用于实现在网页中的各种交互效果。这的确是对javascript的正确描述，在如今看来也是。&lt;/p&gt;

&lt;p&gt;只是，这样的认识容易产生对javascript的低估。web领域的发展是迅速的，javascript也一样。javascript最初只是被设计为用来实现表单验证的客户端语言，现在你却可以看到有许多杰出的开发者使用它做出了非常出色的应用，而且已不再限于浏览器客户端的范围。这些都展现了javascript的巨大威力。因此，要以新的观念来看待javascript。&lt;/p&gt;

&lt;p&gt;javascript所包含的知识和内容是非常多的，即使只介绍基础部分，也远非一篇文章的篇幅可以做到的。因此，本文会较多地从轮廓的角度来描述知识点，但也会针对一部分内容做细节说明，希望对准备学习，或正在学习javascript的你有所帮助。&lt;/p&gt;

&lt;h2&gt;javascript是什么&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;javascript是一门程序设计语言&lt;/em&gt;。此外，在很多的地方，你都可以看到有描述称javascript是&lt;em&gt;灵活的&lt;/em&gt;（&lt;em&gt;flexible&lt;/em&gt;），这种灵活体现在javascript的语法和结构上（后文会有说明）。还有一个有趣的点是你可以看到javascript包含了java一词，但事实是它们之间几乎没有什么关系。&lt;/p&gt;

&lt;h2&gt;javascript可以做什么&lt;/h2&gt;

&lt;p&gt;在过去，javascript被认定为是一种由浏览器解释运行的客户端语言，因此存在一些固有限制，如javascript不能写服务器机器上的文件，某一网页中的javascript不能从来自另一个服务器的已经打开的网页中读取信息（很显然，这是为了用户安全）。如今，浏览器已经不是解释运行javascript的唯一环境，而且新的浏览器也在保证用户安全的基础上，考虑允许javascript实现更多的功能。在现在的web网页开发中，javascript可以实现的，可以说几乎包含了你可以想到的任何事情。&lt;/p&gt;

&lt;p&gt;javascript作为一门独立的程序设计语言，也已被应用到了更多领域。&lt;a href=&quot;http://commonjs.org/&quot; title=&quot;CommonJS&quot;&gt;CommonJS&lt;/a&gt;是一个项目团队，致力于为javascript创建可用于更广泛的应用程序编程的环境（提供运行环境和API），并制定规范。其宗旨是javascript: not just for browsers any more!。其目标是使javascript也可以像其他程序设计语言一样实现服务器端操作，命令行，文件读取等功能。比较有名的&lt;a href=&quot;http://www.nodejs.org/&quot; title=&quot;Node.js&quot;&gt;Node.js&lt;/a&gt;，可以看做是CommonJS的其中一部分的实现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201307/CommonJS_Logo.png&quot; title=&quot;CommonJS&quot; alt=&quot;CommonJS&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;如何使用javascript&lt;/h2&gt;

&lt;p&gt;在web网页开发中，javascript的引入是使用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签，如果是在html中直接写，则是：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;The quick brown fox jumps over the lazy dog.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;更常用的方式是写在单独的.js文件中（实际上，拓展名也不是必须的），然后通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签引用：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;example.js&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面两段代码中，&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;的&lt;code&gt;type&lt;/code&gt;属性不是必须的。出于性能优化的考虑，&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;最好放在页面代码最下部，也即&lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt;标签之前。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;是把代码加载和执行合并在一起的，每一段&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;都会在加载完成后立即执行（严格的说，是在不写&lt;code&gt;async&lt;/code&gt;和&lt;code&gt;defer&lt;/code&gt;属性的情况下）。&lt;/p&gt;

&lt;h2&gt;javascript中可以介绍的语法&lt;/h2&gt;

&lt;h3&gt;区分大小写&lt;/h3&gt;

&lt;p&gt;比如&lt;code&gt;yuki&lt;/code&gt;和&lt;code&gt;Yuki&lt;/code&gt;是两个不同的变量。&lt;/p&gt;

&lt;h3&gt;松散类型的变量&lt;/h3&gt;

&lt;p&gt;变量的声明是javascript代码中最常见的，使用关键字&lt;code&gt;var&lt;/code&gt;。javascript尤其特别的是，它的变量是&lt;em&gt;松散类型&lt;/em&gt;的。也就是说，任一声明的变量都可以存储任何类型的数据。这也一定程度上体现了javascript的高自由度。&lt;/p&gt;

&lt;p&gt;变量声明中，不使用&lt;code&gt;var&lt;/code&gt;也是有效的，但这样会一般造成定义额外的全局变量。根据javascript的最佳实践，全局变量应该尽量避免，因此在变量声明中一定要使用&lt;code&gt;var&lt;/code&gt;关键字。&lt;/p&gt;

&lt;p&gt;javascript中一共有5种简单数据类型（也称为&lt;em&gt;基本数据类型&lt;/em&gt;），和1种复杂数据类型（也称为&lt;em&gt;引用数据类型&lt;/em&gt;），如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;typeA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Undefined类型 这里写成 var typeA; 也是一样的&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;typeB&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Null类型 空&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;typeC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Boolean类型 逻辑值&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;typeD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;twitter&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//String类型 字符串&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;typeE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Number类型 数字&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;typeF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Object类型 对象&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;typeG&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;elem1&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;elem2&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Array类型 数组&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;typeH&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2013&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;19&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Date类型 日期&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;typeI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/^\stext\s$/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//RegExp类型 正则表达式&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;typeJ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Function类型 函数&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;像这样在变量初始化的时候通过初始值说明变量的数据类型，是一个好的实践。变量在未做初始化时，默认值为&lt;code&gt;undefined&lt;/code&gt;（未定义）。上面这段代码中，空行之上的正好对应5种基本数据类型，之下的都属于引用数据类型。你可能会惊奇下面看起来应该是多种类型，但事实上，它们虽然有不同，但都属于引用数据类型，即Object。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.crockford.com/&quot; title=&quot;Douglas Crockford&quot;&gt;Douglas Crockford&lt;/a&gt;在&lt;a href=&quot;http://javascript.crockford.com/private.html&quot; title=&quot;Private Members in JavaScript&quot;&gt;Private Members in JavaScript&lt;/a&gt;一文中提到：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;JavaScript is fundamentally about objects. Arrays are objects. Functions are objects. Objects are objects.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;意思是说，javascript是以Object为基础的语言，除基本数据类型外，其他所有的引用数据类型，本质上都是Object。&lt;/p&gt;

&lt;p&gt;函数是特殊的Object，通过关键字&lt;code&gt;function&lt;/code&gt;声明。它比Object多的一个功能是可以存储任意数量的语句，并且可以通过在函数名后加&lt;code&gt;()&lt;/code&gt;的形式调用，从而执行自身所存储的语句（而且可以传递任意数量的参数）。&lt;/p&gt;

&lt;h3&gt;理解Object&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Object是一组数据和功能的集合&lt;/em&gt;。一个简单的Object的示例：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;myObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//和 new Object() 相同&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;myObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;yuki&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//属性&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;myObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sayHello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//方法&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;Hello! My name is &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;quot;yuki&amp;quot;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;myObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;quot;Hello! My name is yuki&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里&lt;code&gt;name&lt;/code&gt;是&lt;code&gt;myObject&lt;/code&gt;的一个属性，而&lt;code&gt;sayHello&lt;/code&gt;是它的一个方法。可以看到，访问属性，或者调用方法，都是通过点语法&lt;code&gt;.&lt;/code&gt;来实现的。这种使用方法你一定非常熟悉，jQuery就是全局创建了一个名为&lt;code&gt;jQuery&lt;/code&gt;（如果不冲突，还有别名&lt;code&gt;$&lt;/code&gt;）的Object，然后把所有的方法都定义在了这个Object中。&lt;/p&gt;

&lt;h3&gt;对象字面量&lt;/h3&gt;

&lt;p&gt;Object的定义还有一种方式，称为对象字面量表示法，它是定义Object的一种简写形式。比如前面的&lt;code&gt;myObject&lt;/code&gt;，用对象字面量表示法来写的话，是：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;myObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;yuki&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;Hello! My name is &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出，这种写法是，从花括号&lt;code&gt;{&lt;/code&gt;开始，到花括号&lt;code&gt;}&lt;/code&gt;结束，通过 属性名：属性值 的形式，依次定义不同的属性。不同的属性之间以逗号&lt;code&gt;,&lt;/code&gt;分隔，但最后一个属性定义后面没有逗号。&lt;/p&gt;

&lt;p&gt;对象字面量被极多地运用于各类javascript库中，因为这种语法要求的代码量少，而且有封装数据的感觉，更受开发人员青睐。&lt;/p&gt;

&lt;p&gt;数据交换格式JSON（JavaScript Object Notation）的写法和对面字面量非常近似。比如下面这段JSON数据：（自动化工具&lt;a href=&quot;http://gruntjs.com/&quot; title=&quot;Grunt&quot;&gt;Grunt&lt;/a&gt;用到的&lt;code&gt;package.json&lt;/code&gt;配置文件）&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Test App&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;quot;version&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;1.0.0&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;quot;devDependencies&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;quot;grunt&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;~0.4.1&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;quot;grunt-contrib-concat&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;~0.1.1&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和对象字面量相比，JSON对象还是有一些不同。JSON中没有声明变量，同时因为不是javascript语句，末尾没有分号。而且，JSON中，只能使用双引号（javascript中，字符串用单引号和双引号都是可行的），而且属性名也必须有双引号。&lt;/p&gt;

&lt;p&gt;虽然具有相同的语法形式，但JSON并不从属于javascript。关于JSON的更多信息，你可以阅读官方的&lt;a href=&quot;http://www.json.org/json-zh.html&quot; title=&quot;JSON&quot;&gt;JSON介绍&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;如何写javascript来实现功能&lt;/h2&gt;

&lt;p&gt;在学习javascript中，我们更关注的是如何实现一些想要的功能。一般来说，需要实现的功能都是&lt;em&gt;事件驱动&lt;/em&gt;（&lt;em&gt;Event Driven&lt;/em&gt;）的。在初期，这种功能实现会有一个常用的流程写法。jQuery设计的语法非常贴合这个流程。请看下面这个示例：&lt;/p&gt;

&lt;div class=&quot;post_display&quot; style=&quot;width:30px;height:30px;padding:5px;border:1px solid #aaa&quot;&gt;
    &lt;div id=&quot;box&quot; style=&quot;width:30px;height:30px;background:#a1e466;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;框中的填充矩形会在点击后消失。对应的使用jQuery的javascript代码是：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;#box&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;click&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;none&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出，实现一个事件驱动的功能分为三部分，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201307/elementary_procedure_of_event_driven.png&quot; title=&quot;事件驱动的功能的初级实现流程&quot; alt=&quot;事件驱动的功能的初级实现流程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参照这样的逻辑，按照顺序写代码就可以实现初级的事件驱动。如果前面的功能使用原生javascript来实现，则是：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;c1&quot;&gt;//获取元素&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;box&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;box&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//为元素添加事件处理&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//事件处理内容：该元素不再显示， display = &amp;quot;none&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;display&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;none&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可能会觉得原生javascript也并没有多复杂。这是因为这个示例的功能非常简单，而且没有触及存在浏览器兼容性差异的部分。jQuery提供的是简化的、方便的高层次接口，而为了做到这一点，jQuery实际在我们视线之外的区域做了很多复杂的工作，帮助处理原生javascript的浏览器兼容和功能不足等问题。因此，使用jQuery这类javascript库可以让我们的精力更好地集中在程序实现逻辑上。&lt;/p&gt;

&lt;h2&gt;完整的javascript实现的其他组成部分&lt;/h2&gt;

&lt;p&gt;前面所提到语法和实现属于javascript核心（称为ECMAScript，是一种语言标准）。除此以外，完整的javascript还包括另外两部分：&lt;em&gt;浏览器对象模型&lt;/em&gt;（&lt;em&gt;BOM&lt;/em&gt;）和&lt;em&gt;文档对象模型&lt;/em&gt;（&lt;em&gt;DOM&lt;/em&gt;）。&lt;/p&gt;

&lt;h3&gt;BOM&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;BOM&lt;/em&gt;（&lt;em&gt;Browser Object Model&lt;/em&gt;）提供了很多Object对象，用于访问浏览器的功能。其中核心对象是&lt;code&gt;window&lt;/code&gt;，javascript中的一些全局方法，如&lt;code&gt;setTimeout()&lt;/code&gt;、&lt;code&gt;alert()&lt;/code&gt;等，都是定义在&lt;code&gt;window&lt;/code&gt;对象上。&lt;/p&gt;

&lt;p&gt;比如下面一个使用BOM的示例：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;http://acgtofe.com&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其功能是1s后跳转到其他网页。&lt;/p&gt;

&lt;h3&gt;DOM&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;DOM&lt;/em&gt;（&lt;em&gt;Document Object Model&lt;/em&gt;）已是W3C的一个推荐标准，为基本的文档结构和查询提供的接口，它本质上是独立于javascript的，不过，在javascript中可以而且经常需要使用它。&lt;/p&gt;

&lt;p&gt;DOM很容易理解，它描述的就是任何HTML或XML文档中的由各个节点构成的树形结构。比如下面这段HTML：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;wrapper&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;h3&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;title&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Sample Title&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h3&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;content&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Introduction.&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对应的树形结构是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201307/dom_tree.png&quot; title=&quot;javascript错误信息&quot; alt=&quot;dom树形结构&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;javascript调试&lt;/h2&gt;

&lt;p&gt;javascript调试最常用的是全局方法&lt;code&gt;console.log()&lt;/code&gt;，可以用它输出想要跟踪查看的变量，或者单纯地输出一些字符串说明调试语句所在的代码段有没有被执行到。&lt;/p&gt;

&lt;p&gt;浏览器的开发者工具，在控制台中可以查看到当前页面的输出信息（通过&lt;code&gt;console.log()&lt;/code&gt;），以及javascript错误。错误信息还会说明错误位置（文件名，行，列），错误类别，错误说明。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201307/javascript_debug_in_firebug.png&quot; title=&quot;javascript错误信息&quot; alt=&quot;javascript错误信息&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Ajax&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Ajax&lt;/em&gt;（&lt;em&gt;Asynchronous JavaScript and XML&lt;/em&gt;）可以说是真正让javascript流行起来的原因。Ajax的技术核心是XMLHttpRequest对象，它使得javascript可以在任何时候和服务器进行通讯而不必刷新整个页面。&lt;/p&gt;

&lt;p&gt;比如服务器端的一个&lt;code&gt;test.php&lt;/code&gt;文件内容如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;Here is the server.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;?&amp;gt;&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实现Ajax的javascript代码（原生javascript需要较为繁琐的代码，因此这里使用了javascript库Mootools）：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;myRequest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;get&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;test.php&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;onSuccess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;responseText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;elem&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;text&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;responseText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;myRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这段代码所要做的是，获取&lt;code&gt;test.php&lt;/code&gt;返回的文本信息，然后把它写入到一个id是&lt;code&gt;elem&lt;/code&gt;的元素内。这个实例的效果是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201307/ajax_result.png&quot; title=&quot;Ajax实例效果&quot; alt=&quot;Ajax实例效果&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个简单的Ajax实例是为了说明，Ajax虽然概念看上去比较复杂，但理解起来是不难的。&lt;/p&gt;

&lt;h2&gt;进阶的javascript&lt;/h2&gt;

&lt;p&gt;要成为更专业的前端开发者，则需要对javascript有更深刻的认识和理解。javascript虽然能实现各种各样的功能，但只是初级的写法是难以应付更为复杂庞大的web应用的。很多直接按过程编写下来的代码（一般也称为硬编码 hard coded），会因为对情况的限定和依赖较强（高耦合），无法被复用。所以，在javascript的进阶学习阶段，需要考虑的就是编写可维护的javascript。看一下这段代码：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sayName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//使用时&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;instance1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;quot;AIR&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这段代码表述的是javascript的面向对象的程序设计（即非过程）中的组合继承。与它有关的概念对于javascript的初学者来说很有一定难度，但它们对于javascript模块化和独立复用有很大的帮助。如果你开始理解并使用它们，你会感受到javascript语言本身的独特魅力。前面说过javascript比较自由，而越是自由的程序设计语言，越能够体现程序编写者的出色的代码设计构思。&lt;/p&gt;

&lt;p&gt;对javascript有一定的功能实现的经验后，就应该学习&lt;em&gt;javascript设计模式&lt;/em&gt;。设计模式是针对程序设计语言中的各类问题的解决方案，可以帮助你了解专业的javascript代码是如何规划和设计的。如果你希望读懂jQuery这类javascript库的源码，就一定要懂得设计模式。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;看到这里，你可能会觉得这篇文章好像什么也没说。事实上，我在整理这些信息的时候，就确切的感到，javascript的知识真的是很多的，本文只是在尝试以一个全局的视野来描述这门程序设计语言。我也是javascript的学习者之一，所以这些也是我目前对javascript的理解。&lt;/p&gt;

&lt;p&gt;以后关于javascript的一些有趣的细节，我会再做详细的探讨。（目前肯定是还有很多待学习的点的... ￣▽￣ ）&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>琪娅和她的伙伴们 - 谈零之轨迹和碧之轨迹</title>
   <link href="http://acgtofe.com/posts/2013/06/ed-zero-and-ed-ao"/>
   <updated>2013-06-13T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/06/ed-zero-and-ed-ao</id>
   <content type="html">&lt;p&gt;阅读本文时推荐搭配下面的音乐(・ω・)。（Original Soundtrack 零の軌跡）&lt;/p&gt;

&lt;div class=&quot;post_display&quot; style=&quot;height:24px;&quot;&gt;
    &lt;audio src=&quot;http://f.izt8.com/4230941808/1373851596.mp3&quot; preload=&quot;auto&quot; loop&gt;&lt;/audio&gt;
&lt;/div&gt;


&lt;p&gt;我是在等到碧之轨迹也出了PC中文版之后，把两作连在一起玩完的。这样无间断地把两作一同讲述的这个连续的，很有一定长度的完整的故事读完，感觉非常棒。&lt;/p&gt;

&lt;p&gt;作为一个游戏而言，零之轨迹和碧之轨迹沿用的是前作空之轨迹的游戏引擎，因此在画面和游戏体验上有高度的一致性。这个游戏引擎创造的画面在如今的游戏界其实很不够看，但游戏的品质从来就不只是由这些决定的。对于我这样的（以及更多的）轨迹系列的fans而言，“延续”下去的故事就是最重要的。&lt;/p&gt;

&lt;p&gt;轨迹系列有自己完整的游戏内的世界，而且从一开始，轨迹系列就以细腻的剧情令这个世界充满着迷人的魅力。简单的说，轨迹系列是很大的“坑”，但跳下去后读到故事却感到很有价值，并像期待小说和漫画连载一样期待着故事的后续。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/kiseki_logos.jpg&quot; title=&quot;零之轨迹和碧之轨迹&quot; alt=&quot;零之轨迹和碧之轨迹&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;零之至宝的故事&lt;/h2&gt;

&lt;p&gt;空之女神的七至宝是轨迹系列的故事中非常重要的内容。零之轨迹和碧之轨迹所提及的是幻之至宝，但幻之至宝的命运就和前作的空之至宝辉之环很不相同，拥有心灵的幻之至宝在历史途中即以自己的意志选择了自我毁灭。而后来的人们并没有考虑幻之至宝毁灭的原因，并设法重现至宝。这个人造至宝的完成品，就是零之至宝琪雅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/kea_meet.jpg&quot; title=&quot;与琪雅的相遇&quot; alt=&quot;与琪雅的相遇&quot; /&gt;&lt;/p&gt;

&lt;p&gt;零之至宝在原有的幻之力的基础上，还拥有操纵时空的能力，这也成为整个故事的伏笔的关键。在零之轨迹刚开始游戏时的那一小段像梦境一样的经历，直到碧之轨迹终章的结尾才点明。虽然开始会觉得有些莫名其妙，但到一切都明白之后，又会深感是故事上的一个精巧的设定。&lt;/p&gt;

&lt;p&gt;零碧的故事舞台是塞姆里亚大陆西部的克洛斯贝尔自治州。克洛斯贝尔如今已是大陆数一数二的金融和贸易中心，经济实力十分强劲。但对应的，克洛斯贝尔位于埃雷波尼亚帝国和卡尔瓦德共和国这两个大国之间，并不断受到两大国的干涉，政治根基脆弱，局势也很不稳定。同时，黑社会和政治家相互勾结，在看似繁荣的城市背后，有着许多令人担忧的地方。正是在这样的情况下，克洛斯贝尔警察局新设立了部门-特别任务支援科，主角们即成为了这个部门最初的成员，然后投身到保护市民安全，响应市民请求的身为警察的工作中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/bus_waiting.jpg&quot; title=&quot;等待公共汽车中...&quot; alt=&quot;等待公共汽车中...&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相比空之轨迹具有幻想色彩的故事，零碧的故事要“现实”许多，包含了政治斗争、黑社会等因素。而身为警察的罗伊德一行人在应对支援请求（果然还是要做和游击士一样的事啊！）的同时，还会对信息和情况做很多推理，并让玩家来做选择。虽然做侦探的感觉很不错，但RPG的收集要素可是会告诉你，选项选错可是会掉DP的！想要达成一些成就的话，还是求助攻略吧...&lt;/p&gt;

&lt;p&gt;琪雅的确是零碧的核心（零表示作为零之至宝的琪雅，碧表示琪雅的印象色），但在事件发展进程上，真正推动故事进展的，我觉得还是在于克洛斯贝尔自治州这个特定的环境。这种处于两大国之间的困境，每一个热爱着克洛斯贝尔的人都会想着要如何解救克洛斯贝尔，并把克洛斯贝尔变得更好。我们所能看到的，就是零碧所讲述的罗伊德一行人为此所做的努力。而与此同时，罗伊德一行人也经历了与琪雅相遇、成为琪雅的监护人、保护并最终救回琪雅的过程。即使最后还因此陷入了克洛斯贝尔独立战争，但对罗伊德一行人来说，让琪雅像一个普通女孩和同伴们一起，才是正确的做法。本来世上就没有令所有人满意的选项，我们应做的是由自己来决定未来。&lt;/p&gt;

&lt;h2&gt;形形色色的人物&lt;/h2&gt;

&lt;p&gt;特别任务支援科绝对是一个神奇的组织。从一开始就聚在了一起的主角众人，每一位都有着各自的深厚背景和个性。不过，从活跃在各个事件中屡次立功的特别任务支援科的成绩看，正是因为是这样一群各有千秋的角色，特别任务支援科才能一次一次完成那么多困难的任务。&lt;/p&gt;

&lt;p&gt;罗伊德这位呢，约纳留下的一句话最适合描述了：“你这个伪装成温和无害的娃娃脸，实际上却四处拈花惹草的人生赢家！”事实证明，这句话深得玩家的共鸣...罗伊德是一个老好人（艾斯蒂尔也是！），很关心别人，总是能在适当的时候给予同伴鼓舞。而罗伊德作为一号男主，更厉害的一点是在特定的时候所展现出的惊人的分析和推理能力。虽说罗伊德平时就是处处留情而且毫无自知之明，但在关键的时候，却总能分析出正确的结论，带领大家继续行动。（所以这才是主角和队长啊！）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/lloyd_impression.jpg&quot; title=&quot;零碧中最受玩家喜欢的台词-出自罗伊德&quot; alt=&quot;零碧中最受玩家喜欢的台词-出自罗伊德&quot; /&gt;&lt;/p&gt;

&lt;p&gt;艾莉是市长的孙女，身为大小姐却给人平易近人的亲切感。艾莉相比罗伊德在很多方面都要懂得更多，因此也常常斜眼看着罗伊德吐槽他（比如没节操什么的= =）。有些地方也多亏艾莉的帮助，才成功见到一些较有权势的人，渐渐化解挡在面前的壁垒（官二代在是必须的！）。艾莉人很善良，但会在一些细微的点上腹黑一下，众所周知的艾莉的“微笑”审讯，绝对立竿见影。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/elie_impression.jpg&quot; title=&quot;艾莉的“微笑”&quot; alt=&quot;艾莉的“微笑”&quot; /&gt;&lt;/p&gt;

&lt;p&gt;缇欧是队伍里年龄最小的成员，极少露出笑容，在面部表情上显得很“三无”，但话却不少，而且很喜欢吐槽。而实际上缇欧内心温柔，也非常重视同伴。她在导力网络技术上的实力（黑客，也包括玩波波碰这种游戏...）为支援科带来了很有力的帮助。缇欧很喜欢说“好麻烦”（零碧的战斗开始时经常有），而在提到与咪西有关的话题后会立即变得非常健谈。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/tio_impression.jpg&quot; title=&quot;恭喜你们，罗伊德前辈，艾莉前辈。&quot; alt=&quot;恭喜你们，罗伊德前辈，艾莉前辈。&quot; /&gt;&lt;/p&gt;

&lt;p&gt;兰迪是队伍里的大哥，一直给人一种“轻浮”的感觉，擅长各类与夜店有关的技巧，比如赌博、飞镖。同时为人诚实，明确地表示自己喜欢比自己年龄大的漂亮姐姐（真的很诚实的！）。实际上则是非常可靠，对队伍里的其他人照顾有加，在需要的时候会勇敢站出来为大家做掩护
，并敢于担当。完全展现了实力的兰迪则非常帅气，最终S技“狂战士”绝对是华丽丽的视觉效果！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/randy_impression.jpg&quot; title=&quot;如此符合兰迪喜好的塞茜尔却...&quot; alt=&quot;如此符合兰迪喜好的塞茜尔却...&quot; /&gt;&lt;/p&gt;

&lt;p&gt;琪雅外观看上去是9岁左右的小女孩，虽然失去了记忆，但表现得十分乐观开朗，人见人爱。被特别任务支援科的各位收留后不久，就已经和身边的人都混得很熟。可能因为零之至宝的力量的缘故，琪雅非常聪明，可以很快地掌握一些知识和技巧（比如烹饪，第一次尝试后就从此可以为罗伊德一行人做饭了）。琪雅非常喜欢罗伊德他们，并在心里也产生了要“保护罗伊德他们”的想法。现在看来，也许正是因为琪雅的这种想法，才会有零碧这种种的故事吧...&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/kea_impression.jpg&quot; title=&quot;前来送行的琪雅&quot; alt=&quot;前来送行的琪雅&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这几位最主要的角色以外，还有很多非常有个性的配角，比如非常喜欢缇欧的游击士艾欧莉娅（如果下一作还出现的话请务必加上头像！），结尾的 ❤ 是不是一下子就让语气很不同了？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/others_impression_1.jpg&quot; title=&quot;游击士艾欧莉娅&quot; alt=&quot;游击士艾欧莉娅&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分布在游戏内各个场景的NPC，也不只是简单的NPC。这也是轨迹系列一直以来的在细节上认真的地方。每名NPC都有自己的背景和故事，他们并不会固定在一个场景，随着游戏流程的进行，各个NPC人物可能会出现在不同的地方，而且会有不同的对话（更新频率很快，而且有些可以反映出目前所处的故事时间线位置）。所以，这些NPC就是在以一个可能是旁观者的身份，活跃着，和玩家一同见证着这块大陆上的故事。想要更多地了解这个世界，就请多从NPC那里打听。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/others_impression_2.jpg&quot; title=&quot;活跃的NPC&quot; alt=&quot;活跃的NPC&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;觉得印象深刻很想提一下的地方&lt;/h2&gt;

&lt;p&gt;碧之轨迹为新的战术导力器增加了“核心回路”系统，实际用起来，尤其觉得其搭配的核心魔法非常好用。而且，发动核心魔法的卡片也非常精美！下图中从左到右依次是地、水、火、风、时、空、幻（七曜属性）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/seven_cards.jpg&quot; title=&quot;七属性的核心魔法卡片&quot; alt=&quot;七属性的核心魔法卡片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;零碧虽然是新的主角，新的故事，但前作空之轨迹中的角色却也巧妙地安排到了零碧的故事中。一切都是在告诉我们：这就是你熟悉的轨迹中的世界！（所以历代主角互相认识是个定律么...）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/familiar_friends.jpg&quot; title=&quot;几个拥有相同朋友的人的愉快的闲聊&quot; alt=&quot;几个拥有相同朋友的人的愉快的闲聊&quot; /&gt;&lt;/p&gt;

&lt;p&gt;钓鱼仍然是轨迹系列里休闲活动的代表，碧轨里的钓杰四天王不仅有不错的实力，还有着充分的自信，比如这位龙宫辉夜...&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/fishing_special.jpg&quot; title=&quot;哦呵呵!哦呵呵呵!呵呵呵……&quot; alt=&quot;哦呵呵!哦呵呵呵!呵呵呵……&quot; /&gt;&lt;/p&gt;

&lt;p&gt;越狱这一段令我非常震撼，这样和过去的敌人一同并肩作战，而且还全程搭配了超燃的音乐！(音乐名是Inevitable Struggle，非常推荐！)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/prison_break.jpg&quot; title=&quot;无装备无魔法2vN!&quot; alt=&quot;无装备无魔法2vN!&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;轨迹系列的之后&lt;/h2&gt;

&lt;p&gt;结社“噬身之蛇”的计划实施在轨迹系列的整个主线故事中有很强的引导作用。碧之轨迹中涉及的结社的幻焰计划，实则分为两部分，幻指幻之至宝，实施地点就在克洛斯贝尔，而焰的部分将会在埃雷波尼亚帝国展开。到碧轨结束，玩家也触及不到这整个计划的全貌。&lt;/p&gt;

&lt;p&gt;很令人期待的是，接下来的“闪之轨迹”的故事正设定在了埃雷波尼亚帝国，但从轨迹系列的一贯安排来看，是否在闪之轨迹这一作就继续涉及结社的计划，还是很难说的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201306/tio_sd.jpg&quot; title=&quot;我就看看...&quot; alt=&quot;我就看看...&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外，碧轨也是falcom用这个古老的引擎做的最后一款游戏了（仅限轨迹系列），接下来的闪之轨迹会使用PS3级别的游戏引擎，同时角色会用真人比例的3D人物模型（其实轨迹系列的Q版人物模型也很好看的！），不知道又会给玩家带来怎样不同的印象。等到时候玩到游戏，我会再来发表一下感受，敬请期待。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>像素与浏览器视口的细节</title>
   <link href="http://acgtofe.com/posts/2013/05/pixel-and-viewport"/>
   <updated>2013-05-31T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/05/pixel-and-viewport</id>
   <content type="html">&lt;p&gt;初学网页制作，很常见的做法就是找各种线上的网页，然后查看源代码，参考学习这些网页是如何实现自己的设计的。而对我来说，我印象最深的一个知识点，是这样的：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;wrapper&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nc&quot;&gt;.wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;980px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;margin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个在现在来看，其实就是经典的固定宽度的网页布局。不过，以前的时候，我并不知道为什么这样做就可以。当时的理解是：一个定宽，水平居中的容器，来容纳网页的主体内容，就可以使网页能在不同分辨率的显示屏都有相对较好的表现。而对于浏览器窗口这样一个摆放网页的“物件”，还有相当一些未理解的地方。&lt;/p&gt;

&lt;p&gt;网页布局并不只有这一种做法。不像这样简单地使用一个固定宽度的外层容器，同样可以做出在各种状况下都有较好表现的网页。不过，这种时候，就需要对页面布局原理有更深的了解，从而准确地控制好网页元素，保证按照预定的方式显示。&lt;/p&gt;

&lt;p&gt;本文将介绍像素及浏览器视口的概念，并解释说明与它们相关的，前端开发应理解的要点细节。本文主要参考了quirksmode.org上的&lt;a href=&quot;http://www.quirksmode.org/mobile/viewports.html&quot; title=&quot;A tale of two viewports&quot;&gt;A tale of two viewports&lt;/a&gt;，在这里非常推荐你也阅读一下（注意，这篇文章分为两部分）。&lt;/p&gt;

&lt;h2&gt;从像素开始&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;像素&lt;/em&gt;（&lt;em&gt;Pixel&lt;/em&gt;）是数字图像的最小组成单元，它不是一个物理尺寸，但和物理尺寸存在一个可变的换算关系（物理尺寸之间的换算是固定的）。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;PPI&lt;/em&gt;（&lt;em&gt;Pixel Per Inch&lt;/em&gt;）是指每英寸包含的像素数，同时也是针对这个换算关系的一个描述性指标。其中的英寸（Inch）和厘米（cm）、毫米（mm）等尺寸一样，都属于物理尺寸。不同的显示设备会有不同的PPI，因此，每一个像素点的物理尺寸（可以理解为你如果能拿刻度尺来量的话，得到的数值），也会因为设备的不同而存在差异。一般来说，越高的PPI，相当于在单位物理尺寸内用了更多、更小的像素点来显示图像，因此会更清晰。&lt;/p&gt;

&lt;p&gt;在Photoshop中，对图像大小的表示，有“像素大小”以及“文档大小”两个区域，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201305/photoshop_image_size.png&quot; title=&quot;Photoshop中的图像大小&quot; alt=&quot;Photoshop中的图像大小&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你也许注意过，这里无论改写哪个区域的数值，另一个区域的数字也会相应变化。因此，像素大小和文档大小只是在用不同的方式，表达同一图像的尺寸信息。任何时候，它们之间都可以用“分辨率”数值（比如这里是PPI）进行换算。&lt;/p&gt;

&lt;p&gt;与PPI类似的，还有一个&lt;em&gt;DPI&lt;/em&gt;（&lt;em&gt;Dot Per Inch&lt;/em&gt;），是指每英寸打印的点数，表示了打印机的打印精度，是属于印刷行业的概念。但如今随着数字化的输入输出设备的发展，很多人也把数字图像的解析度用DPI来表示。严格来说，印刷时计算的网点和电脑显示器的显示像素并不相同，但现在已普遍认同，数字图像显示屏的信息，用DPI或PPI表示均可行，是相同的含义。&lt;/p&gt;

&lt;h2&gt;设备像素与css像素&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;设备像素&lt;/em&gt;（&lt;em&gt;device pixels&lt;/em&gt;）是指与硬件设备直接相关的像素，是真实的屏幕设备中的像素点。比如说，一个电脑显示器的参数中，最佳分辨率是1920x1080，那么指的就是这个显示器在屏幕上用于显示的实际像素点，也就是设备像素。&lt;/p&gt;

&lt;p&gt;另一个概念是&lt;em&gt;css像素&lt;/em&gt;（&lt;em&gt;css pixels&lt;/em&gt;）。css像素是指网页布局和样式定义所使用的像素，也就是说，css代码中的px，对应的就是css像素。那么，css像素和设备像素有什么区别呢？简单地说，css像素比设备像素要更“虚拟”一些。下面来解释这一点。&lt;/p&gt;

&lt;p&gt;在桌面电脑上，浏览器有一个很少使用的功能：&lt;em&gt;缩放&lt;/em&gt;。比如下边这个矩形元素，宽度是128px，高度是40px。显然，这里的尺寸是css像素。&lt;/p&gt;

&lt;div class=&quot;post_display&quot;&gt;
    &lt;div style=&quot;width:128px;height:40px;background:#38a1ff;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;然后，缩放本页（&lt;code&gt;ctrl&lt;/code&gt; + &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;ctrl&lt;/code&gt; + &lt;code&gt;-&lt;/code&gt;），注意一下，你看到了什么？&lt;/p&gt;

&lt;p&gt;矩形元素的css像素尺寸没有变化，同样，你的显示器的设备像素尺寸也不会变化。但是，放大后，元素看起来变大了，在你的屏幕上占据了更大的空间。对应地，如果是缩小，则元素看起来变小了，在屏幕上占据的空间也变小了。&lt;/p&gt;

&lt;p&gt;css像素和设备像素之间是一种可变的转化关系。&lt;em&gt;在100%缩放比例下，1个css像素等于1个设备像素&lt;/em&gt;。在表示某一数目的css像素时，在放大状态下使用了更多的设备像素，而在缩小状态下使用了更少的设备像素。这就是css像素和设备像素的概念。&lt;/p&gt;

&lt;p&gt;对前端开发来说，设备像素没有意义，我只会关心css像素。只有css像素才描述了网页的布局与外观，我只需要让我的网页在100%缩放比例下看起来不错就可以了。&lt;/p&gt;

&lt;p&gt;在css中，大部分人都习惯于使用&lt;code&gt;px&lt;/code&gt;作为元素宽度或高度定义的单位。css中可也可以使用其他单位，比如&lt;code&gt;in&lt;/code&gt;英寸这样的物理尺寸单位。联系前文的内容，你一定会困惑这些单位的关系。css是这样做的：如果你使用&lt;code&gt;in&lt;/code&gt;这类物理尺寸，它会直接转化为css像素。这个转化关系是固定的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1in == 96px 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于css单位的详细内容，你可以阅读CSS-Tricks上的&lt;a href=&quot;http://css-tricks.com/the-lengths-of-css/&quot; title=&quot;The Lengths of CSS&quot;&gt;The Lengths of CSS&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;视口&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;视口&lt;/em&gt;（&lt;em&gt;viewport&lt;/em&gt;），指的是浏览器窗口中用来显示网页的区域。以桌面电脑的浏览器来说，就是浏览器窗口除去标题栏，菜单栏，地址栏，状态栏等等浏览器的“周边”的东西后剩余的区域。&lt;/p&gt;

&lt;h3&gt;桌面电脑中的视口&lt;/h3&gt;

&lt;p&gt;桌面电脑中的视口，一般来说是这样的印象：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201305/viewport_on_desktop.jpg&quot; title=&quot;桌面电脑中的视口&quot; alt=&quot;桌面电脑中的视口&quot; /&gt;&lt;/p&gt;

&lt;p&gt;视口是存在着一些特性的，要讨论它，就要分析&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;这两个元素。&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;是任何网页都必然存在的元素，但它们的表现及特性却很少被提及。现在，通过一个例子来说明。&lt;/p&gt;

&lt;p&gt;假设&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;有一个做自适应布局的直接子元素，比如说侧边栏，定义了&lt;code&gt;width:20%&lt;/code&gt;，然后调整浏览器窗口大小，你会看到元素会相应做尺寸调整（如果你用前端工具查看，可以看到元素的宽度的计算值，也即css像素，是变化的），始终在视口中占据20%的宽度（这里也假定所有元素都没有内外边距和边框）。这是如何做到的？&lt;/p&gt;

&lt;p&gt;可以想到，侧边栏的20%是取了父级元素，也就是&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;的宽度值。那&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;有多宽呢（没有给它定义宽度）？显然，&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;作为块元素，会取父元素，也就是&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;的100%宽度值。最后一个问题，&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;有多宽？是的，同样，&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;作为块元素，会再依照一个宽度值取100%，这个宽度值就是视口的宽度。&lt;/p&gt;

&lt;p&gt;因此，可以理解为，视口表现得像是&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;之上的一个块元素，它限制并确定&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;的宽度，但却不属于html结构，不能被设置样式。而且，任何时候，视口的尺寸都会随着浏览器窗口的大小变化而变化。桌面电脑中的视口，就是这样的一个概念。&lt;/p&gt;

&lt;p&gt;也许，你见过这样的问题：在全屏状态下看起来不错的网页，如果调整为一个比较小的浏览器窗口，然后再在这个时候拖动一下横向的滚动条，就会有不协调的地方。比如下图这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201305/viewport_trouble.jpg&quot; title=&quot;较小的视口时有可能存在的问题&quot; alt=&quot;较小的视口时有可能存在的问题&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，联系一下视口与网页中的元素之间的显示关系，就可以知道原因了。在这样浏览器窗口较小的时候，视口较小，&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;也受视口影响，宽高变得比较小，而带背景图或背景色的元素是取父元素的100%宽度，因此，会只有这样的宽度。&lt;/p&gt;

&lt;p&gt;这里会出现问题，也是因为有其他网页元素定义的宽度超过了此时的&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;的宽度，从而使一部分元素在水平方向上出现在了视口之外。如果要解决这个问题，为带背景图或背景色的元素，定义一个最小宽度即可。&lt;/p&gt;

&lt;h3&gt;手机中的视口&lt;/h3&gt;

&lt;p&gt;相比桌面电脑，在手机上浏览网页，最大的差异在于屏幕尺寸。如果你拿手机来看一个平时用桌面电脑浏览的网页，那么一定会经历下面两种状态：页面被缩小，以至于文字无法阅读，或者处于适中的缩放比例，但只显示了整个网页的一小部分。&lt;/p&gt;

&lt;p&gt;手机浏览器的供应商致力于让用户在手机上也获得最佳的网页浏览体验，这也是说，要让手机浏览网页的体验能够“尽可能地和桌面电脑相同”。&lt;/p&gt;

&lt;p&gt;然后，手机浏览器的供应商是这么考虑的：由于手机屏幕的宽度对于css网页布局来说太小，为了让更多的网页能正常显示（一些流体布局的网页会在过窄的视口中变得一团乱），应该让视口更宽，超越屏幕的宽度。所以，在手机浏览器中，视口被划分为了两个：&lt;em&gt;可见视口&lt;/em&gt;（&lt;em&gt;visual viewport&lt;/em&gt;）和&lt;em&gt;布局视口&lt;/em&gt;（&lt;em&gt;layout viewport&lt;/em&gt;）。&lt;/p&gt;

&lt;p&gt;可见视口是指当前在手机屏幕上显示的部分。当你做缩放的时候，可见视口的尺寸（css像素值）也会变化。如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201305/visual_viewport_on_mobile.jpg&quot; title=&quot;手机上的可见视口&quot; alt=&quot;手机上的可见视口&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和可见视口不同，布局视口用于元素布局和尺寸计算（比如百分比的宽度值），而且比可见视口明显要更宽。无论你缩放，或者滑动页面，甚至翻转手机屏幕，布局视口始终不变。前文介绍过&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素会取视口的宽度值，在手机上，这个限定和确定&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;的是布局视口。这就是手机浏览器在处理时和桌面电脑浏览器不一样的地方，而这个布局视口的引入，保证了网页在手机里中的显示与在桌面电脑上的一致。&lt;/p&gt;

&lt;p&gt;布局视口的宽度是由手机浏览器定义的，随浏览器不同而不同。比如Safari是980px，Android   Webkit是800px。这都远比屏幕宽度值要大。&lt;/p&gt;

&lt;p&gt;你可以做一个测试：写一个整体只有300px宽的网页，但不针对手机做任何处理（也就是代码写法和桌面电脑网页一样），然后用手机打开。你会看到，即使页面内容没有超过手机屏幕宽度，页面仍然会被大比例缩小，就好像这个页面“是一个很宽的桌面电脑网页”。这个测试可以说明布局视口的存在。&lt;/p&gt;

&lt;h3&gt;更改手机中的布局视口&lt;/h3&gt;

&lt;p&gt;手机中的布局视口是可以更改的。你一定在很多移动版网页中见到过下边这个&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签元素。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;viewport&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是最早由Safari引入，但如今已普遍被各类手机浏览器认可了的一项设置。这其中有一句&lt;code&gt;width=device-width&lt;/code&gt;，它的意思是，把手机浏览器的布局视口的宽度，更改为当前设备的宽度。你还可以使用&lt;code&gt;width=500&lt;/code&gt;这样的具体数值（也是css像素值）。总的来说，使用这个&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签元素，就可以告诉手机浏览器当前页面应该使用的布局视口的尺寸。&lt;/p&gt;

&lt;p&gt;关于这个viewport meta tag的更多信息，你可以阅读Mozilla开发团队写过的&lt;a href=&quot;https://developer.mozilla.org/en/mobile/viewport_meta_tag&quot; title=&quot;Using the viewport meta tag to control layout on mobile browsers&quot;&gt;关于viewport meta tag的文章&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;与媒体查询的关系&lt;/h2&gt;

&lt;p&gt;css中的&lt;code&gt;@media&lt;/code&gt;媒体查询可以根据尺寸信息分别定义不同的css。其中，可用的值有2种，&lt;code&gt;width/height&lt;/code&gt;和&lt;code&gt;device-width/device-height&lt;/code&gt;。这两种尺寸信息有什么区别呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;width/height&lt;/code&gt;使用的是视口的尺寸值，如果是手机，则是布局视口的尺寸值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;device-width/device-height&lt;/code&gt;使用的是设备屏幕的尺寸值。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在桌面电脑上，如果你写：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;k&quot;&gt;@media&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;max-width&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;:600px&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/*特定样式，只在宽度不大于600时有效*/&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么，只需要调整浏览器尺寸到一定程度，你就可以看到这部分特定样式生效后的效果。但是，如果把这里的&lt;code&gt;max-width&lt;/code&gt;换成&lt;code&gt;max-device-width&lt;/code&gt;，那么，无论做什么，都无法看到这部分特定样式生效，因为整个显示器的宽度是不会变化的。因此，在桌面电脑上，你只需要使用&lt;code&gt;width&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而在手机上，如果网页有前面说的&lt;code&gt;width=device-width&lt;/code&gt;的定义（目前几乎所有移动版网页都做了这样的定义），那么使用&lt;code&gt;width&lt;/code&gt;和&lt;code&gt;device-width&lt;/code&gt;是相同的。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;由像素及浏览器视口引入的相关知识还有不少，本文受限于篇幅（如果太长了我实在觉得不能拿来看...（ ﾟ口ﾟ）），只以尽可能明确的方式，介绍了主要的部分。如果有任何疑惑的地方，欢迎讨论。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>css进阶 - 从选择符开始</title>
   <link href="http://acgtofe.com/posts/2013/05/better-css-selectors"/>
   <updated>2013-05-20T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/05/better-css-selectors</id>
   <content type="html">&lt;p&gt;在我最早开始写css的时候，其代码上的高自由度就一直很令我困惑。这就是说，同一个设计，如果让不同的人来实现，最终的代码一定是有差异的。但这存在一个问题，如果不同的人通过不同的方法以及代码风格，都从外观上实现了一样的设计，将很难评价谁做得更好。想来也是，既然都实现了设计，达到了目的，css这种没有程序逻辑的代码中，又能找出什么来说明谁做得更出色呢？&lt;/p&gt;

&lt;p&gt;而如今，我认同的观念是，css这种描述性语言，仍然有着代码上的质量评判。评判标准就是&lt;em&gt;可维护性&lt;/em&gt;（&lt;em&gt;Maintainability&lt;/em&gt;）和&lt;em&gt;性能&lt;/em&gt;（&lt;em&gt;Performance&lt;/em&gt;），用比较通俗的话说，好的css，要对开发者的工作友好（dev-friendly），也要对浏览器友好（browser-friendly）。 本文将说明如何从css选择符的角度来提高css代码质量。&lt;/p&gt;

&lt;h2&gt;关键选择符与浏览器的样式规则匹配原理&lt;/h2&gt;

&lt;p&gt;css选择符的概念，在之前的&lt;a href=&quot;http://acgtofe.com/posts/2013/04/css-specificity-explain-in-detail/&quot; title=&quot;css优先级详细解析&quot;&gt;css优先级详细解析&lt;/a&gt;的开头部分也有提到，是指每一条样式规则中，描述把样式作用到哪些元素的部分，也即&lt;code&gt;{}&lt;/code&gt;之前的部分。在本文，还要额外介绍一个概念：&lt;em&gt;关键选择符&lt;/em&gt;（&lt;em&gt;Key selector&lt;/em&gt;）。关键选择符就是在每一条样式规则起始的&lt;code&gt;{&lt;/code&gt;之前的最后一个选择符，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201305/key_selector_explain.png&quot; title=&quot;css关键选择符&quot; alt=&quot;css关键选择符&quot; /&gt;&lt;/p&gt;

&lt;p&gt;css选择符将确定后面的属性定义要作用到哪些元素,因此存在一个浏览器根据css选择符来应用样式到对应元素的匹配过程。关于浏览器的样式匹配系统，David Hyatt在&lt;a href=&quot;http://www.mozilla.org/xpfe/goodcss.html&quot; title=&quot;Writing Efficient CSS&quot;&gt;Writing Efficient CSS for use in the Mozilla UI&lt;/a&gt;一文中提到了以下内容：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The style system matches a rule by starting with the rightmost selector and moving to the left through the rule’s selectors. As long as your little subtree continues to check out, the style system will continue moving to the left until it either matches the rule or bails out because of a mismatch.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;意思是说，浏览器引擎在样式匹配时，以&lt;em&gt;从右向左&lt;/em&gt;的顺序进行。在具体匹配某一条样式规则时，这个从右向左的过程会一直持续，直到读取完整个选择符序列并完成匹配，或因某一个地方的不匹配而取消（然后转到另一条样式规则）。&lt;/p&gt;

&lt;p&gt;至于为什么浏览器会选择这样的匹配顺序，你可以看看&lt;a href=&quot;http://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left&quot; title=&quot;Why do browsers match CSS selectors from right to left?&quot;&gt;Stack Overflow上的相关讨论&lt;/a&gt;。大致上解释一下的话，由于最右边的关键选择符直接表示了样式定义应作用的元素，所以从右向左的顺序更利于浏览器在初始匹配的时候就确定有样式定义的元素集合，并更快地在找某一个元素的样式时避开大多数实际没有作用到的选择符。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;更好的css选择符，是让浏览器在样式匹配过程中减少匹配查询次数，以更快的速度完成样式匹配，从而优化前端性能&lt;/em&gt;。这其中，也必须参考浏览器的对于样式从右向左的匹配顺序。&lt;/p&gt;

&lt;h2&gt;css选择符的正确使用方式&lt;/h2&gt;

&lt;h3&gt;更特定，更具体的关键选择符&lt;/h3&gt;

&lt;p&gt;关键选择符是浏览器引擎在样式匹配时最先读取到的部分，因此，如果你在某一条样式规则中使用更特定、具体的选择符，可以帮助减少浏览器的查找匹配次数。&lt;/p&gt;

&lt;p&gt;比如说下边这样的选择符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.content .note span{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一个&lt;code&gt;span&lt;/code&gt;是关键选择符，而&lt;code&gt;span&lt;/code&gt;这个标签，在网页中使用是非常多的。浏览器从&lt;code&gt;span&lt;/code&gt;开始读取选择符，就可能会为因此在样式匹配上做了一些额外工作。&lt;/p&gt;

&lt;p&gt;如果你确定只是想为具体处于那一个位置的&lt;code&gt;span&lt;/code&gt;元素定义样式，更好的做法是为&lt;code&gt;span&lt;/code&gt;命名class，比如命名为&lt;code&gt;span.note_text&lt;/code&gt;，然后简单写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.note_text{}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;使用class选择符&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;class选择符（类选择符）是最利于性能优化的选择符&lt;/em&gt;。相对于class，ID的缺点是只允许定义给一个元素，无法重用。而此外，它在使用上没有任何比class更好的地方。很多时候，你很难确定某一个元素是否是唯一的。另外，使用class来定义样式，而保留ID给javascript，一直是一个较好的实践。如果可以，不使用ID来定义样式。&lt;/p&gt;

&lt;p&gt;而相对于class，标签在html中的重复性要更大，因此同样可能让浏览器在样式匹配时做更多的额外工作。如果可以，除css样式清零（reset）外，不使用标签选择符（也叫元素选择符）。&lt;/p&gt;

&lt;h3&gt;缩短选择符序列&lt;/h3&gt;

&lt;p&gt;继承写法（准确地说，这里指css关系选择符中的包含选择符）是css中很常用的写法。继承写法的初衷是，如果有两个元素，都是同样的标签或有相同的class命名，加入父元素的选择符组成选择符序列，就可以避免在不需要的时候两个元素的样式互相影响。比如&lt;code&gt;.confirm_layer .submit_btn&lt;/code&gt;就是指，class名为&lt;code&gt;submit_btn&lt;/code&gt;，且有一个class名为&lt;code&gt;confirm_layer&lt;/code&gt;的父元素的元素，才应用样式。&lt;/p&gt;

&lt;p&gt;但是，避免元素样式相互影响，并不代表可以随意地使用继承选择符。前面提到，浏览器会从右向左读取整个选择符序列，直到读取完毕并匹配完成，或者因不匹配而取消。因此，&lt;em&gt;短的选择符序列更有利于浏览器更快地完成匹配过程&lt;/em&gt;。相对的，冗长的选择符序列则认为是低效的，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.header ul li .nav_link{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.header .nav_link{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来说，不超过3层的继承层级就可以满足实际中的开发要求。因此，应减少不必要的继承层级，使用更短的选择符序列。&lt;/p&gt;

&lt;p&gt;此外，较长的选择符序列还有一个问题。有较长选择符的样式规则，css优先级的计算值也较大，因此，如果在以后需要写新的样式来覆盖掉它，就需要写更长的选择符（或者使用ID）以获得更高的css优先级。这对性能和代码可读性都是不利的。&lt;/p&gt;

&lt;h3&gt;避免链式选择符&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;链式选择符&lt;/em&gt;（&lt;em&gt;Chaining selectors&lt;/em&gt;）是对单个元素同时写了多个选择符判定的情况。比如&lt;code&gt;p.name&lt;/code&gt;是指class名为&lt;code&gt;name&lt;/code&gt;，且标签是&lt;code&gt;p&lt;/code&gt;的元素，才应用样式。这些判定组合可以是ID选择符，标签选择符，class选择符的任意组合。&lt;/p&gt;

&lt;p&gt;但是，链式选择符是过度定义（over qualified）的，不利于重用，也不利于性能优化。如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a#author{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#author{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;a&lt;/code&gt;是不必要的。一个ID只对应一个元素，没有必要再强调这个元素的标签是什么（同理，class也不必）。另外有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.content span.arrow{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.content .arrow{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;span.arrow&lt;/code&gt;中的&lt;code&gt;span&lt;/code&gt;也是不必要的。一方面，这为浏览器在样式匹配时增加了一项额外工作：检查class名为&lt;code&gt;arrow&lt;/code&gt;的元素的标签名是不是&lt;code&gt;span&lt;/code&gt;，也因此降低了性能。另一方面，如果去掉了这个限定，&lt;code&gt;.arrow&lt;/code&gt;的样式定义，就可以用在更多的元素上，也就有着更好的重用性。否则，就还得告诉别人，使用这个的时候只能用在&lt;code&gt;span&lt;/code&gt;标签上。&lt;/p&gt;

&lt;p&gt;同理，多个class的链式写法，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.tips.succuss{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议更改命名，写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.tips_succuss{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样可以帮助浏览器减少额外的样式匹配工作。&lt;/p&gt;

&lt;p&gt;此外，IE6还存在一个链式选择符的问题，多个class选择符写在一起时，例如&lt;code&gt;.class1.class2.class3&lt;/code&gt;，正常情况是只有同时有这全部的class的元素，才应用样式。但IE6只认最后一个，也就是符合&lt;code&gt;.class3&lt;/code&gt;这个选择符的元素，就应用样式。&lt;/p&gt;

&lt;h2&gt;例外情况&lt;/h2&gt;

&lt;p&gt;前面所述的选择符的写法的建议，只是从浏览器渲染性能优化，及代码的重用性方面分析得到的理论结果。在实际使用中，你并不需要严格按照这些内容来做。例如，如果你确实是准备为class名为&lt;code&gt;intro&lt;/code&gt;的元素内的所有&lt;code&gt;a&lt;/code&gt;标签元素都加上某样式，那么&lt;code&gt;.intro a&lt;/code&gt;这样的选择符是明智的。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;关于高效的css选择符的指南，你还可以阅读google developer中的&lt;a href=&quot;https://developers.google.com/speed/docs/best-practices/rendering#UseEfficientCSSSelectors&quot; title=&quot;Use efficient CSS selectors&quot;&gt;Use efficient CSS selectors&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如今，现代浏览器在样式匹配上也逐渐有了更多的优化（参考&lt;a href=&quot;http://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/&quot; title=&quot;CSS Selector Performance has changed! (For the better)&quot;&gt;CSS Selector Performance has changed!&lt;/a&gt;），有些方面的内容我们已经不再需要再担心了。但是，这并不意味着不需要考虑写合理的css选择符了。css选择符性能优化是依然存在的事，你的选择符应该更好地体现你的意图，而不是随心所欲地使用。更重要的是，以这样一种稍细腻的，经过思考的想法来写css选择符，并不是一件困难的事。只要你想，形成这样的一种习惯，你就可以自然地在这方面做得更好，何乐而不为呢？&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>css优先级详细解析</title>
   <link href="http://acgtofe.com/posts/2013/04/css-specificity-explain-in-detail"/>
   <updated>2013-04-21T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/04/css-specificity-explain-in-detail</id>
   <content type="html">&lt;p&gt;css不是一种程序语言，而是一种描述语言。因此，可以说，css理解起来是非常容易的，大部分人通过简单的学习就可以懂得如何写css代码来定义网页的样式。但是，大部分人同样也会在写css的过程中产生很多困惑，比如为什么自己写的某段css没有生效，或者呈现出的样式和预计的不同，但又不知道要如何解决。&lt;/p&gt;

&lt;p&gt;造成这些问题的主要因素，是&lt;em&gt;css优先级&lt;/em&gt;。css优先级是css中最难理解的概念之一，但对于掌握css来说非常重要。理解css优先级，不仅有利于快速解决样式问题，而且能在布局层面，帮助我们写出更明晰，更合理的css代码。&lt;/p&gt;

&lt;h2&gt;什么是css优先级&lt;/h2&gt;

&lt;p&gt;css的组成单元是&lt;em&gt;样式规则&lt;/em&gt;（&lt;em&gt;CSS Rule&lt;/em&gt;），单条样式规则的形式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/css_rule_explain.png&quot; title=&quot;样式规则&quot; alt=&quot;样式规则&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，&lt;em&gt;选择符&lt;/em&gt;（&lt;em&gt;Selector&lt;/em&gt;）决定了后边所写的属性定义会作用到哪些元素，因此称为选择符。&lt;/p&gt;

&lt;p&gt;css有一个核心特性，当多条样式规则中的同一个属性（比如&lt;code&gt;padding&lt;/code&gt;）作用到了同一个元素，这些样式之间就会发生覆盖：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/undoing_style_example.png&quot; title=&quot;css样式覆盖示意&quot; alt=&quot;css样式覆盖示意&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中由前端调试工具所显示的，被划掉的css样式，不会呈现在这里选中的网页元素上，因为它们被覆盖掉了。css优先级，就是指在这种情况下，得出“应该由哪一条样式规则的内容覆盖掉其他的”这个结论的过程中所遵循的原则。更一般的表述是，&lt;em&gt;优先级高的css样式，将覆盖优先级低的css样式，成为最终网页元素的实际样式&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;注意，前端调试工具显示的，”被划掉“的css样式，并不是说一定是完全覆盖。css中的一些组合属性（比如&lt;code&gt;margin&lt;/code&gt;，可以拆分为&lt;code&gt;margin-top&lt;/code&gt;、&lt;code&gt;margin-right&lt;/code&gt;、&lt;code&gt;margin-bottom&lt;/code&gt;、&lt;code&gt;margin-left&lt;/code&gt;），在这种样式覆盖中遵循的是局部覆盖的原则，即使在前端调试工具中它们看起来“整个都被划掉了”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/rollup_property_overwrite.png&quot; title=&quot;组合属性覆盖&quot; alt=&quot;组合属性覆盖&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;css优先级的影响因素&lt;/h2&gt;

&lt;p&gt;css优先级的影响因素要考虑三部分内容，&lt;em&gt;css选择符权重&lt;/em&gt;、&lt;em&gt;!important标识符&lt;/em&gt;、&lt;em&gt;属性继承&lt;/em&gt;。很多文章都阐述过css选择符权重这一点，但后面两部分却很少被提及。本文会依照这三部分做详细的说明。&lt;/p&gt;

&lt;h2&gt;属性继承&lt;/h2&gt;

&lt;p&gt;css中一部分属性是&lt;em&gt;可继承属性&lt;/em&gt;，比如文本颜色&lt;code&gt;color&lt;/code&gt;。css优先级的讨论，首先应认清css中的属性继承所带来的影响。由于存在可继承属性，一个网页元素的样式来源可以分为两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由css选择符直接定义到元素&lt;em&gt;本身&lt;/em&gt;的样式。&lt;/li&gt;
&lt;li&gt;css选择符未作用到，但&lt;em&gt;继承&lt;/em&gt;自父级元素的样式。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;em&gt;定义到元素本身的样式，包括浏览器默认样式，一定比继承得到的样式优先级高&lt;/em&gt;。因此，可以这样认定：继承得到的样式的优先级是最低的，在任何时候，只要元素本身有同属性的样式定义，就可以覆盖掉继承值：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/inherit_property_overwrite.png&quot; title=&quot;可继承属性覆盖&quot; alt=&quot;可继承属性覆盖&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而且，继承样式是最低优先级这一点，是&lt;em&gt;无视继承样式所在的样式规则的内容&lt;/em&gt;的。这就是说，继承样式所在的样式规则，即使其选择符的权重比元素本身样式的选择符的权重更高（本文后文会介绍选择符权重~ :) ），甚至继承样式被写了&lt;code&gt;!important&lt;/code&gt;，继承样式会被元素本身样式覆盖这一点仍然成立。&lt;/p&gt;

&lt;p&gt;举例来说明。下面这段html：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;container&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;note_text&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;acgtofe - 动漫与前端技术的综合博客&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对应的css：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nf&quot;&gt;#container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;darkblue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;.note_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;darkorange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个部分在所有浏览器中的效果都是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/inherit_regardless_of_selector_specificity.png&quot; title=&quot;继承属性优先级原则无视选择符权重&quot; alt=&quot;继承属性优先级原则无视选择符权重&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再为原来的css增加&lt;code&gt;!important&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nf&quot;&gt;#container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;darkblue&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;!important&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;.note_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;darkorange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，会发现所有浏览器中的效果都不变：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/inherit_regardless_of_important.png&quot; title=&quot;继承属性优先级原则无视!important&quot; alt=&quot;继承属性优先级原则无视!important&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当一个元素有多个父级元素都定义了继承样式，这些继承样式之间的优先级又是怎样的？这时候，遵循的优先级原则可以叫做&lt;em&gt;就近原则&lt;/em&gt;，也就是说，&lt;em&gt;在存在多个继承样式时，层级关系距离当前元素最近的父级元素的继承样式，具有相对最高的优先级&lt;/em&gt;。同样，这时候也是无视样式规则内容的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/multiple_inherit.png&quot; title=&quot;多个继承属性时的优先级&quot; alt=&quot;多个继承属性时的优先级&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就近原则其实不算是新的结论，想一下，如果把每一个父级元素都作为当前元素，然后按照前边的“元素本身样式大于继承样式”的原则推理一遍，就可以明白，离得最近的父级元素的继承样式优先级最高，是很合理的。&lt;/p&gt;

&lt;h2&gt;css选择符权重&lt;/h2&gt;

&lt;p&gt;css选择符权重是css优先级的核心概念。但在考虑css选择符权重前，请记住，这条优先级原则涉及的样式都是指&lt;em&gt;定义在元素本身的样式&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;每一条样式规则的选择符，除了决定这条样式规则会作用到哪些元素之外，选择符也是浏览器判断css规则优先级的参考信息。css选择符权重不是简单的内容，但却可以用简单而直观的方法做阐述。&lt;/p&gt;

&lt;p&gt;css选择符权重是一个数字游戏，比的就是谁的计算值更大。&lt;em&gt;权重计算值大的样式规则将有更高的优先级&lt;/em&gt;。你可以想象为龙珠里的战斗力测量，在这场权重战争（&lt;a href=&quot;http://www.stuffandnonsense.co.uk/archives/css_specificity_wars.html&quot; title=&quot;CSS: Specificity Wars&quot;&gt;Specificity Wars&lt;/a&gt;，这也是早期的一篇阐述css优先级的文章中用到的词）中，战斗力最强的将取得胜利。&lt;/p&gt;

&lt;p&gt;战斗力的测量方法是统计选择符中的不同组成元素的个数，并以 (a,b,c,d) 这种形式来判断。其中，abcd分别代表了不同类别的选择符组成元素，且战斗力分别在不同的数量级，a最强，d最弱。从弱到强，这4个字母分别代表的类别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;元素选择符（Element），伪元素选择符（Pseudo Element） d = 1 – (0,0,0,1)&lt;/li&gt;
&lt;li&gt;类选择符 （Class），伪类选择符（Pseudo class），属性选择符（Attribute） c = 1 – (0,0,1,0)&lt;/li&gt;
&lt;li&gt;Id选择符 b = 1 – (0,1,0,0)&lt;/li&gt;
&lt;li&gt;内联样式（Inline style） a = 1 – (1,0,0,0)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这里的&lt;em&gt;伪元素&lt;/em&gt;和&lt;em&gt;伪类&lt;/em&gt;做一下补充说明。伪元素选择符，指的是样式作用到的元素不是html结构中的实际元素，即不是真正的dom元素。目前只有&lt;code&gt;:before&lt;/code&gt;，&lt;code&gt;:after&lt;/code&gt;，&lt;code&gt;:first-line&lt;/code&gt;，&lt;code&gt;:first-letter&lt;/code&gt;和&lt;code&gt;::selection&lt;/code&gt;这5个伪元素选择符。伪类选择符，则是指除前边的这部分选择符之外，在css中加入冒号&lt;code&gt;:&lt;/code&gt;的，用于实现动态效果与智能控制的选择符，比如&lt;code&gt;:hover&lt;/code&gt;，&lt;code&gt;:nth-of-type(n)&lt;/code&gt;。从css3开始，通过区别使用双冒号&lt;code&gt;::&lt;/code&gt;来表示伪元素，单冒号&lt;code&gt;:&lt;/code&gt;来表示伪类，但为了和以前的浏览器兼容，&lt;code&gt;:after&lt;/code&gt;这种诞生于css2的伪类选择符仍然允许使用单冒号的写法。&lt;/p&gt;

&lt;p&gt;现在，可以找一些css选择符计算一下了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/specificity_calculate_example.png&quot; title=&quot;css选择符权重计算举例&quot; alt=&quot;css选择符权重计算举例&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看过这些例子后，请理解为，简单的分类计数，正是css中的战斗力测量方法。(a,b,c,d) 这种形式中，abcd分别是不同的数量级，a&gt;b&gt;c&gt;d，和数字的大小比较方法相同，从高位开始，如果高位数字相同，则取低一位数字比较，以此类推。&lt;em&gt;选择符权重计算值最大的样式规则中的属性，覆盖其他的样式规则中的同名属性&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;如果你觉得自己计算麻烦，请到&lt;a href=&quot;http://specificity.keegan.st/&quot; title=&quot;Specificity Calculator&quot;&gt;Specificity Calculator&lt;/a&gt;，这是一个非常棒的计算器。&lt;/p&gt;

&lt;p&gt;(a,b,c,d) 中，a代表的内联样式实际是存在于html代码中，只能取值为0或1，所以和其他的较为不同。后边的bcd虽说是不同的数量级，但详细说来有多大差距呢？请看下面这一段&lt;a href=&quot;http://hg.mozilla.org/mozilla-central/file/17c65d32c7b8/layout/style/StyleRule.cpp#l521&quot; title=&quot;mozilla-central source&quot;&gt;Firefox浏览器源代码&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/firefox_css_selector_source.png&quot; title=&quot;Firefox浏览器源代码-StyleRule&quot; alt=&quot;Firefox浏览器源代码-StyleRule&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出，class和id对应的十六进制数值之间隔了2位，所以，在Firefox中，要256（16&lt;sup&gt;2&lt;/sup&gt;）个class才相当于1个id。在不同浏览器中，这种层级差距，可能有所不同。在写本文的时间点，Opera和Chrome中用256+的class也不能大于id的权重。不过，这些细节信息并不重要，你在实际使用中不可能用到这个数量的选择符。所以，应认为前面所述的权重计算方法是可靠的。&lt;/p&gt;

&lt;p&gt;如果权重计算值相同，则进入后一个环节：样式定义顺序。&lt;/p&gt;

&lt;h3&gt;样式定义顺序&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;权重计算值相同的样式规则，定义顺序靠后的优先级高&lt;/em&gt;。这里的定义顺序，包含了所有的静态样式（不包括由javascript创建&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;元素引入的样式）定义的可能情况。如直接写在html的&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;标签内的样式规则，通过&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;引入的css文件，以及&lt;code&gt;@import&lt;/code&gt;引入的css文件。&lt;/p&gt;

&lt;p&gt;请记住，只有权重计算值相同的时候，你才需要考虑样式定义顺序。&lt;/p&gt;

&lt;h2&gt;!important标识符&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;!important&lt;/code&gt;是可以写在样式规则中的某一属性定义值后的标识符，用于提升某一属性的样式定义的优先级。不同于决定整条样式规则优先级的css选择符权重，&lt;code&gt;!important&lt;/code&gt;只影响自己所在位置的单一属性。&lt;code&gt;!important&lt;/code&gt;在优先级原则中，可以理解为前文的(a,b,c,d)结构中的，比a更高位的标识：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/position_of_css_important.png&quot; title=&quot;!important在优先级原则中的位置&quot; alt=&quot;!important在优先级原则中的位置&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后，你完全再按照前文的css选择符权重的比较方法，就可以得出在这种情况下的css优先级了。具体说的话，可以表述如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写有&lt;code&gt;!important&lt;/code&gt;标识符的样式，其优先级一定大于没有该标识符的样式。&lt;/li&gt;
&lt;li&gt;在都写有&lt;code&gt;!important&lt;/code&gt;标识符的样式之间，再按照一般的css选择符权重的优先级原则做判断。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;css优先级的浏览器兼容性&lt;/h2&gt;

&lt;p&gt;css优先级虽然是不简单的内容，但幸运的是，除IE6和IE7存在少量优先级的bug（详见&lt;a href=&quot;http://www.brunildo.org/test/IEASpec.html&quot; title=&quot;IE Specificity bugs&quot;&gt;IE Specificity bugs&lt;/a&gt;）外，几乎所有浏览器都很一致地遵循css优先级原则。所以，css优先级是很通用的概念，可以在各种情况下应用而不必担心兼容性。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;css优先级的概念在本文就介绍到此。本文所阐述的仍有不够全面的地方，如果你碰到一些新的问题，欢迎来这里讨论。在实际应用中，理解css优先级并不是让我们去这样分析每一条样式规则，而只是让我们有一个更清醒的状态，知道如何去布局和控制自己所写的css。所谓“知己知彼，百战不殆”，也是这样的道理。&lt;/p&gt;

&lt;p&gt;css全名是层叠样式表（Cascading Style Sheet），css优先级正是这种“层叠”中所遵循的原则，由此也可以看出css优先级的重要性。最后，以一个自制的图来结尾：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/special_card_css_specificity_war.jpg&quot; title=&quot;CSS Specificity War&quot; alt=&quot;CSS Specificity War&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Love Live! ED 主题曲 - きっと青春が聞こえる</title>
   <link href="http://acgtofe.com/posts/2013/04/lovelive-ed"/>
   <updated>2013-04-14T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/04/lovelive-ed</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/lovelive_ed_cd_cover.jpg&quot; title=&quot;Love Live! ED - きっと青春が聞こえる&quot; alt=&quot;Love Live! ED - きっと青春が聞こえる&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;post_display&quot; style=&quot;height:24px;&quot;&gt;
    &lt;audio src=&quot;http://f.izt8.com/4230941808/1373851589.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;
&lt;/div&gt;


&lt;p&gt;歌词（自译）&lt;/p&gt;

&lt;p&gt;&lt;small&gt;素直に追いかけて　勇気で追いかけて〖坦率地去追寻　以勇气去追寻〗&lt;br/&gt;
小さな願いが明日を作る〖小小的愿望化作明天〗&lt;br/&gt;
できるかも　みんなが望むなら〖只要大家期望　就能够做到〗  &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;誰より頑張っちゃえ　とにかく情熱のままに〖比谁都更努力　保持满腔的热情〗&lt;br/&gt;
目指すのは綺麗な風吹く道〖以那美丽的　风吹着的道路为目标〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;羽のように　腕あげて〖像展翅一样张开双臂〗&lt;br/&gt;
まぶしい未来へと飛ぶよ〖向那灿烂的未来飞去〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;きっと青春が聞こえる　その瞬間に聞こえる〖一定能听到青春的音符　就在那个瞬间〗&lt;br/&gt;
笑顔ならいつの日も大丈夫！〖保持微笑的话　每天都能过得愉快〗&lt;br/&gt;
きっと青春が聞こえる　その瞬間が見たいね〖一定能听到青春的音符　想要见证那个瞬间〗&lt;br/&gt;
となりに君がいて(嬉しい景色)〖你就在我身旁(令人高兴的景色)〗&lt;br/&gt;
となりは君なんだ〖我的身旁就是你〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;素顔で会いたいよ　元気に会いたいよ〖想素颜相见　想充满活力地相见〗&lt;br/&gt;
きらきら流れる陽射しの元で〖灿烂地照耀着的阳光下〗&lt;br/&gt;
話すのは　みんなのこれからさ〖要说的　是大家从今以后的事〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;誰かが言ってたよ　自分を信じれば叶う〖有人说过　相信自己就可以实现愿望〗&lt;br/&gt;
わかるかも奇跡はつかめるはず〖也许理解的话就可以发生奇迹〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;悔しさを　受けとめて〖所有的后悔　都接受〗&lt;br/&gt;
描いた世界への旅は〖朝着描绘出的世界走出的旅程〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;やっと青春の始まり　この快感をあげたい〖终于到了青春的开始　想要给予这份快感〗&lt;br/&gt;
どこまでも伸びてゆく誇らしさ〖任何地方都一直在增长的自豪感〗&lt;br/&gt;
やっと青春の始まり　この快感が好きだよ〖终于到了青春的开始　喜欢这份快感〗&lt;br/&gt;
本当に君はいて(素敵さいつも)〖你真的存在(一直都很出彩)〗&lt;br/&gt;
本当の君のため〖为了真正的你〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;きっと青春が聞こえる　その瞬間に聞こえる〖一定能听到青春的音符　就在那个瞬间〗&lt;br/&gt;
笑顔ならいつの日も大丈夫！〖保持微笑的话　每天都能过得愉快〗&lt;br/&gt;
きっと青春が聞こえる　その瞬間が見たいね〖一定能听到青春的音符　想要见证那个瞬间〗&lt;br/&gt;
となりに君がいて(嬉しい景色)〖你就在我身旁(令人高兴的景色)〗&lt;br/&gt;
となりは君なんだ〖我的身旁就是你〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;（附：音频播放支持来源于&lt;a href=&quot;http://kolber.github.io/audiojs/&quot; title=&quot;audio.js&quot;&gt;audio.js&lt;/a&gt;）&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>jQuery使用的最佳实践</title>
   <link href="http://acgtofe.com/posts/2013/04/jquery-best-practice"/>
   <updated>2013-04-03T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/04/jquery-best-practice</id>
   <content type="html">&lt;h2&gt;引言&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;jQuery&lt;/em&gt;可以说是web开发领域应用最为广泛的轻量级javascript库，不仅专业的web开发者使用它，很多刚入门的web开发者或者web爱好者也通过使用jQuery轻松地融入到了javascript的开发。&lt;/p&gt;

&lt;p&gt;而如果你还希望在这方面做得更好，就应学习和了解最佳实践。&lt;em&gt;最佳实践&lt;/em&gt;（&lt;em&gt;Best Practice&lt;/em&gt;）是随某一技术领域的发展而逐渐建立起来的关于最新技术和开发方法的信息，在web开发领域也非常有用。&lt;/p&gt;

&lt;p&gt;本文内容参考了杰出前端工程师 &lt;a href=&quot;http://addyosmani.com/blog/&quot; title=&quot;Addy Osmani&quot;&gt;Addy Osmani&lt;/a&gt; 的 &lt;a href=&quot;https://speakerdeck.com/addyosmani/jquery-performance-tips-tricks&quot; title=&quot;jQuery Performance TIPs &amp;amp; Tricks&quot;&gt;jQuery Performance TIPs &amp;amp; Tricks&lt;/a&gt; ，如果有兴趣，你也可以自己看看这位大师的这个演说PPT，Addy Osmani本人也是jQuery的核心团队（jQuery Core teams）的成员之一。&lt;/p&gt;

&lt;h2&gt;为什么需要遵循jQuery最佳实践&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;web开发领域对于性能的追求是永不停滞的&lt;/em&gt;。jQuery虽然是非常强大的开发工具，但不当的使用方法仍会给浏览器带来额外的工作和负担，也会使开发的web应用占用更多的系统资源，运行起来也更慢。而我们都知道，好的web应用需要的是清爽灵活。&lt;/p&gt;

&lt;p&gt;如何判断javascript的性能呢？现在，这种性能测试都可以归纳为运行速度，简单的说，&lt;em&gt;同一项功能，某一种写法如果比另一种写法运行起来更快，那么这种写法就可以实现更好的性能&lt;/em&gt;。当然，这里只单纯从性能角度来考虑，并不包含代码的可维护性。如果你想自己测试不同的javascript代码段的性能，推荐使用 &lt;a href=&quot;http://jsperf.com/&quot; title=&quot;jsperf.com&quot;&gt;jsPerf.com&lt;/a&gt; ，这个站点可以帮助你轻松创建javascript性能测试用例，还可以保存和分享测试结果。jQuery团队也使用它进行javascript性能测试。&lt;/p&gt;

&lt;h2&gt;jQuery使用建议&lt;/h2&gt;

&lt;h3&gt;1.使用最新版&lt;/h3&gt;

&lt;p&gt;新版本的jQuery提供的API会在性能上有所提升，而且修复了一些存在的bug。由于非常多的网站都在使用jQuery，所以jQuery每一个新版本的更改都会经过非常严格的测试，升级一般都不会带来问题。&lt;/p&gt;

&lt;p&gt;此外，新版本的jQuery可能会在API上做非常有用的改动，让开发工作更加简单。比如在jQuery 1.7之前，事件绑定使用&lt;code&gt;bind()&lt;/code&gt;、&lt;code&gt;delegate()&lt;/code&gt;以及&lt;code&gt;live()&lt;/code&gt;这几个方法。虽然都是事件绑定，但每个方法各有针对，这就产生了“什么时候应该使用哪个”的麻烦事。而从jQuery 1.7开始，新增并推荐使用&lt;code&gt;on()&lt;/code&gt;和&lt;code&gt;off()&lt;/code&gt;这2个方法来完成所有的事件绑定与移除，理解起来就要容易多了。&lt;/p&gt;

&lt;h3&gt;2.理解你的选择符&lt;/h3&gt;

&lt;p&gt;在jQuery中，不是所有的选择符（Selectors）都是同等性能的。也就是说，虽然某一些元素你可以用很多种不同的选择符写法来选取，但不要认为它们在性能上也是一样的。&lt;/p&gt;

&lt;p&gt;jQuery的选择符的运行速度是不同的，从最快到最慢依次是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ID选择符（&lt;code&gt;$(#ElementId)&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;元素选择符（&lt;code&gt;$(form)&lt;/code&gt;，&lt;code&gt;$(input)&lt;/code&gt;等）&lt;/li&gt;
&lt;li&gt;Class选择符（&lt;code&gt;$(.someClass)&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;伪类和属性选择符（&lt;code&gt;$(:hidden)&lt;/code&gt;，&lt;code&gt;$([attribute=value])&lt;/code&gt;等）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;由于浏览器支持的原生DOM操作方法（比如&lt;code&gt;document.getElementById()&lt;/code&gt;）就可用，所以ID选择符和元素选择符是最快的。而稍慢的Class选择符是因为IE6-IE8不支持原生的&lt;code&gt;getElementsByClassName()&lt;/code&gt;，而在支持这个原生方法的其他现代浏览器中，Class选择符仍是很快的。&lt;/p&gt;

&lt;p&gt;至于最慢的伪类和属性选择符，则是因为浏览器并不提供对应功能的可用原生方法。尽管jQuery尝试了使用&lt;code&gt;querySelector()&lt;/code&gt;和&lt;code&gt;querySelectorAll()&lt;/code&gt;这两个原生选择符API（属于css查询API）来提升部分jQuery选择符在部分现代浏览器中的性能，但综合起来，仍然是比较慢的。当然，这也是在于jQuery对伪类和属性选择符这个API要求较高，不仅要支持&lt;code&gt;input[type=&quot;text&quot;]&lt;/code&gt;这种css中合法的选择符，还要支持&lt;code&gt;p:first&lt;/code&gt;这类用于元素过滤，但在css中不合法的选择符。总之，jQuery的伪类和属性选择符功能很强大，但请慎重使用。&lt;/p&gt;

&lt;h3&gt;3.缓存你操作的元素&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;.parents&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;children&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;.parents&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;.child&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//bad&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;缓存是指保存jQuery选择符的返回结果，方便之后再次调用。每一个&lt;code&gt;$('.whatever')&lt;/code&gt;都会重新从DOM中搜索并返回一个jQuery包装集（jQuery collection），因此要避免重复使用。&lt;/p&gt;

&lt;p&gt;原生javascript中，建立局部变量来缓存数据或对象，有利于精简代码、优化性能。这里也是一样的道理。&lt;/p&gt;

&lt;h3&gt;4.链式语法&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;.parents&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;doSomethingElse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;jQuery中大部分方法都返回jQuery包装集并支持这种链式语法。javasript的性能优化要点之一是最小化语句数，因此链式语法不仅写起来更容易，运行起来也会更快。&lt;/p&gt;

&lt;h3&gt;5.使用事件代理&lt;/h3&gt;

&lt;p&gt;利用事件冒泡，指定一个位于dom较高层级的元素（比如&lt;code&gt;document&lt;/code&gt;）的事件处理程序，就可以管理某一类型的所有事件。减少了页面中添加的事件处理程序，自然可以提升整体性能。&lt;/p&gt;

&lt;h3&gt;6.最小化现场更新&lt;/h3&gt;

&lt;p&gt;如果你进行操作的DOM部分是已经显示的页面的一部分，那么你就是在进行一个&lt;em&gt;现场更新&lt;/em&gt;。现场更新需要浏览器重新计算尺寸，涉及到重绘（repaint）和回流（reflow），有较高的性能花费，因此应减少使用。&lt;/p&gt;

&lt;p&gt;在新增内容时，建议先把要新增的代码段合并完全，最后再使用单个&lt;code&gt;append()&lt;/code&gt;方法添加到页面。而如果元素存在复杂的交互，比如反复地添加和移除，&lt;code&gt;detach()&lt;/code&gt;这个针对性的方法就是最佳的选择。&lt;/p&gt;

&lt;h3&gt;7.不在不必要的时候使用jQuery方法&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;.nav_link&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;nav id: &amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;id&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//bad&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;jQuery方法不一定是最好的方法。这里使用&lt;code&gt;$(this).attr('id')&lt;/code&gt;获取当前事件元素的ID，为当前事件元素创建了jQuery包装集，然后调用&lt;code&gt;attr()&lt;/code&gt;属性获取方法。但这都是额外的性能花费。事实上，&lt;code&gt;this&lt;/code&gt;在事件函数内就表示当前事件元素，直接使用&lt;code&gt;this.id&lt;/code&gt;就可以获取元素ID，这种原生DOM属性的写法要更快。&lt;/p&gt;

&lt;h3&gt;8.适当使用jQuery工具函数&lt;/h3&gt;

&lt;p&gt;操作jQuery包装集的方法（也就是写在&lt;code&gt;$.fn&lt;/code&gt;中的方法），其中一部分也有作为jQuery工具函数（直接写在&lt;code&gt;$&lt;/code&gt;中的方法）的同类方法。由于jQuery工具函数在使用中不涉及创建jQuery包装集，因此，在部分情况下，可以通过换用jQuery工具函数提升性能。&lt;/p&gt;

&lt;p&gt;比如，在DOM中存储数据，一般的做法是：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;#elem&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//common way&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但改为下边的写法会快很多：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//significantly faster&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要的注意的是，虽然下面这种方法更快，但作为参数传入的元素不能用选择符，而要用元素本身。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;我自己整理和写本文内容时，也感觉很有收获。jQuery是一个很强大的工具，但进一步说，也只提供了web开发的最基本的内容，更高级更复杂的内容，还需要自己不断学习和创作。在这个过程中，遵循最佳实践，养成良好的习惯，会有很大的益处，并逐渐做得更出色！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>社会秩序与人类意志的选择—PSYCHO-PASS分析与感想</title>
   <link href="http://acgtofe.com/posts/2013/03/thoughts-of-psycho-pass"/>
   <updated>2013-03-26T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/03/thoughts-of-psycho-pass</id>
   <content type="html">&lt;p&gt;在不久的未来，随着科学的不断进步，人类灵魂的秘密也被揭开，社会也由此发生了革命性的变化。人类的心理状态与性格倾向都可以测量并数值化，所有的心理倾向都被记录和管理，这其中可以成为每个人的灵魂的判定标准的测量数值，被人们称为&lt;em&gt;PHYCHO-PASS&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/psycho_pass_title.jpg&quot; title=&quot;PSYCHO-PASS&quot; alt=&quot;PSYCHO-PASS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;建立在这种心灵测量数值的基础之上的，被称为&lt;em&gt;西比拉系统&lt;/em&gt;（&lt;em&gt;SIBYL SYSTEM&lt;/em&gt;）的社会管理系统，则通过对社会的每一个人的PHYCHO-PASS进行分析和管理，读取每个人的心理的愿望，个体能力及职业适应性，为每一个人给出最适合的生活方式，并以此建立了一个较为理想和稳定的社会。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/mental_color.jpg&quot; title=&quot;色相&quot; alt=&quot;色相&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PHYCHO-PASS的信息的视觉化，反映为&lt;em&gt;色相&lt;/em&gt;，心理状态良好，色相则趋向于白色，心理状态消极，色相则趋于黑色。在色相健康的情况下，PHYCHO-PASS中的信息之一，称为&lt;em&gt;犯罪系数&lt;/em&gt;，会维持在较低的状态。因为某些原因犯罪系数上升，则会被要求接受心理治疗。而当犯罪系数超过指定数值，则会被认定为犯罪者或潜在犯罪者。&lt;/p&gt;

&lt;p&gt;在这个社会，公安局是最为重要的秩序核心。它的刑事科成员，由&lt;em&gt;监视官&lt;/em&gt;和&lt;em&gt;执行官&lt;/em&gt;组成的队伍，则担负着抓捕或处决犯罪者及潜在犯罪者，维护社会治安的重要责任。PHYCHO-PASS的故事由此展开。&lt;/p&gt;

&lt;h2&gt;监视官和执行官&lt;/h2&gt;

&lt;p&gt;大雨，被封锁的案件现场。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“我是即日起被配属到刑事科的常守朱,请多多指教...”&lt;/p&gt;

&lt;p&gt;“抱歉，我们刑事科现在非常缺人，没工夫把你作为新人看待了。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;由此，常守朱成为刑事科一班的第二位监视官，和宜野座伸元监视官一同，带领狡啮慎也、征陆智己、滕秀星和六合冢弥生四位执行官作为刑事科一班执行任务。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;监视官&lt;/em&gt;，如字面意义所示，对执行官进行监控，指挥，并对执行官的行为负责。监视官必须有良好的精神状态，犯罪系数也必须在规定范围内。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/official_logo.png&quot; title=&quot;公安局刑事科&quot; alt=&quot;公安局刑事科&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“接下来将要见的家伙们，可不要当做一样的人类来看待。他们是PSYCHO-PASS的犯罪系数超过规定数值的人格破裂者，他们本应作为潜在罪犯而被隔离，唯一允许他们进行的社会活动，就是抓获同为犯罪者的人。他们是猎犬，是为狩猎野兽而存在的野兽，他们便是执行官。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;执行官&lt;/em&gt;是监视官的下属，必须在监视官的陪同下才可以行动，是执行任务的最前线的人。和作为目标的犯罪者有同样气息的他们，更有能力找到和抓捕犯罪者。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“犯罪或者制止犯罪，无论选择哪条路都需要犯罪的才能。……因此才会有我们这些接脏活的猎犬。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;监视官和执行官使用的警用枪械—&lt;em&gt;Dominator&lt;/em&gt;（&lt;em&gt;支配者&lt;/em&gt;），具有严格的使用者及目标的识别系统，在枪口瞄准的时候即可测得目标的犯罪系数，只有犯罪系数超过指定值的犯罪者或潜在犯罪者，才会解除保险允许射击。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/banner_dominator.jpg&quot; title=&quot;Dominator&quot; alt=&quot;Dominator&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;犯罪认知&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;“犯罪系数，265，确认为执行对象，解除安全限制。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;依靠西比拉系统，案件处理只需要检测犯罪嫌疑人的犯罪系数，就可以断定出犯罪者。此外，在公共区域常设的色相扫描仪，以及巡视的无人机，也会监测每一个人的犯罪系数，随时向公安局报告异常。&lt;/p&gt;

&lt;p&gt;任何人有过涉及犯罪的行为，或者有犯罪倾向，这些原本深藏于人类内心的信息现在却可以被侦测出。基于这种心灵辨识系统，社会拥有了针对犯罪行为的革命性的控制力。&lt;/p&gt;

&lt;p&gt;但是，许多问题的根源也在此。&lt;/p&gt;

&lt;h2&gt;人生设计&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;“能者成能事，这正是西比拉为人类带来的恩惠。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;我们常说，当所有的东西都在正确的位置的时候，一切都可以平稳运行。西比拉系统测定每个人的个体能力，并给出每个人对应的适合的职业。每个人都不必再困惑于做这些选择，西比拉系统针对每个人所给出的答案，就是这个人正确的、会过得快乐的生活方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/banner_city.jpg&quot; title=&quot;城市&quot; alt=&quot;城市&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么，当一切依托于西比拉系统的时候，西比拉系统本身就必须要求&lt;em&gt;完美&lt;/em&gt;。然而，正如自然界的一般规律，西比拉系统也无法做到完美。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“对将来毫无期待的人生，你们这些被系统祝福的人是不会明白的。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;依照西比拉系统的认定，每个人的个体能力都不相同，优秀的人可以有很多机会，可以从事更多更好的工作，而不被系统认可的人则直接被否决了从事许多工作的可能性，无论这些人自身有多么期望做其他的自己想做的工作。这种差别对待让一部分人对系统抱有怨恨，并感慨“神是不公平的“。但是，这也实际上是任何阶级社会都必然存在的问题。&lt;/p&gt;

&lt;h2&gt;人类意志&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;&quot;我啊，认为人们只有在依靠自身意志行动时才拥有价值，所以，我才追寻各种各样的人的潜在想法，并观察他们的行为。&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;西比拉系统的判定在社会总体上为人类带来恩惠的同时，却也忽略了人类的&lt;em&gt;个人意志&lt;/em&gt;。槙岛圣护这位谜一样的男子，策划并诱导了一系列犯罪案件，并希望能通过研究这个社会中的犯罪者们的心理，获取人类意志的秘密，以此肯定人类的存在价值。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“换做是没有西比拉诊断的时代，能不能幸福可是得看运气来的，和以前比起来要好多了吧。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;在这个社会里，当人们面临各种选择的时候，都会倾向于依靠西比拉系统的判定，而无需烦恼于如何做选择。依照西比拉系统的判定去做，自身会过得更幸福，社会也能获得繁荣和稳定。但是，所谓幸福的定义是什么，人生的意义又是什么？在某些人看来，不以自己的个人意志来决定自己的人生，就无法实现幸福和人生意义。自己是应该按照自己所希望的方式活着，还是应该考虑到“为了这个社会好”而遵从社会所希望的自己的方式活着？&lt;/p&gt;

&lt;h2&gt;免罪体质&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;“如果存在能够制裁我的人，那一定是可以凭借自身意志杀人的人。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;免罪体质&lt;/em&gt;，指的是PSYCHO-PASS扫描仪的测量值和犯罪心理并不一致的特殊案例，人数极少，而且这个概念本身是公安局的高层机密。本质而言，是免罪体质者的PSYCHO-PASS无法被西比拉系统解析，因此也就无法被西比拉系统管理，因此也称为特异者。拥有免罪体质的槙岛圣护，自出生起，无论何种情况下，犯罪系数都不会高于指定数值，色相也一直维持纯白的状态。&lt;/p&gt;

&lt;p&gt;免罪体质者永远不会被西比拉系统认定为犯罪者。这些免罪体质者的存在，令人不得不对西比拉系统抱有怀疑和敌意。而槙岛圣护自己，正如狡啮慎也所说，并不把这看做是一种特权，相反，槙岛圣护因为自己无法被西比拉系统解析并纳入社会管理，有着强烈的孤独感，不能被纳入社会，也就是没有被社会承认是“人类”。槙岛圣护决定要研究与目前的社会所不同的，自己以至人类的价值所在。&lt;/p&gt;

&lt;h2&gt;西比拉系统的真相&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;“成为西比拉系统成员的最重要的资格要求是，必须拥有不同于既存人类规范的异常人格，能以非人类的眼光来俯瞰裁定人类的行为。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;随着故事发展，西比拉系统的真相也被揭开。西比拉系统实际上是大量的具有免罪体质的人类大脑的集合体，拥有自己的作为集合体的思想。也就是说，如果西比拉系统是在“统治”着整个社会，那么仍然是“人”在“统治”着整个社会。但西比拉系统自己认为，“他们”早已是超越人类之上的存在，不能再定义为“人类”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/sibyl_system.jpg&quot; title=&quot;西比拉系统&quot; alt=&quot;西比拉系统&quot; /&gt;&lt;/p&gt;

&lt;p&gt;依照西比拉系统自身给出的理论，单纯的改善系统，使系统复杂化，是无法实现完美的。所以，换一个角度考虑，得出的结论就是，将系统无法管理的特异者集合在一起，并从中分析寻求出一种共存的手段，便可以得到管理社会的正确的方法。西比拉系统通过不断的吸纳那些与一般人有明显的差距的拥有崭新思想和价值观的人加入，使自己思考的幅度不断扩张，并由此不断进化。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“理想的官吏，借用马克斯·韦伯的话来说，就是既不会愤怒，也不会不公，既没有憎恨，也没有激情，既没有爱，也不会狂热，自始至终只履行自身义务的人。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;从社会学的角度来说，西比拉系统可以说是法制社会的一种极致。考虑一下法制社会，我们理想的情况是，法律完善，在法律面前，所有人都要平等接受审判，法律规定了什么是正确的，什么是不正确的，什么样的行为是犯罪行为。在法制社会，不容许个人主观认定犯罪。而另一方面，法制社会中的法律终归是由人制定，由人来确保执行力，而且体现的也是多数人所能共同认可的内容。结合西比拉系统这个人类大脑的集合体来说，是不是确实有很多相似的地方？&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“系统这东西，比起让其完美地运行，一直相信其是完美的这一点更加重要。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;法制社会中的法律，是无法完善到能正确处理社会生活的每一个细节的。而类似的西比拉系统，也因为免罪体质者的存在，不能认为是完美的。但是，相比于法律世界的辩护和裁决，西比拉系统“看上去”更像是一个只机械化履行义务的符合理想需要的&lt;em&gt;秩序管理者&lt;/em&gt;。人们相信并依赖西比拉系统，才因此有了目前的繁荣和稳定的社会。&lt;/p&gt;

&lt;h2&gt;终局&lt;/h2&gt;

&lt;p&gt;狡啮慎也与槙岛圣护，最终都以自己的个人意志，结束了两人之间的对决。善与恶，是与非，此时都已不再重要，他们都以行动贯彻了自己所坚持的信念，即使是在这个充满秩序的社会中被认为是错误的道路，他们也决心要走下去。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/members_on.jpg&quot; title=&quot;刑事科一班&quot; alt=&quot;刑事科一班&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一切都结束之后，已经成长为出色可靠的监视官的常守朱，来了西比拉系统的面前。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“不要小看人类，我们无论何时都在追求着更好的社会，总会有一天有人来关掉这个房间的电源，一定会找到崭新的道路给你看。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;作为这个社会基石的西比拉系统依然存在。至少，目前的社会还不能失去西比拉系统。但是，常守朱坚信着一个不一样的未来。&lt;/p&gt;

&lt;p&gt;依然是一场大雨，以及被封锁的案件现场。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“我是即日起被配属于刑事科的霜月美佳，请多多指教。”&lt;/p&gt;

&lt;p&gt;“抱歉，我们刑事科现在非常缺人，虽然我们会帮助你，但没工夫把你作为新人看待了。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;常守朱冷静地回答道。仍然是刑事科一班，但一切却又变得那么不同。常守朱带领下的刑事科一班的故事还将继续。&lt;/p&gt;

&lt;p&gt;进化着的西比拉系统，以及始终追求着更好社会的人类。社会秩序与人类意志的碰撞下，未来究竟又会如何呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（注：PSYCHO-PASS，译为心理测量者，2012年10月番，一共22集，是动画公司Production I.G制作的原创动画）&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>简单实现固定在页面底部的页脚</title>
   <link href="http://acgtofe.com/posts/2013/03/sticky-footer"/>
   <updated>2013-03-13T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/03/sticky-footer</id>
   <content type="html">&lt;h2&gt;页脚的位置问题&lt;/h2&gt;

&lt;p&gt;网页的页脚（footer），也就是通常用来放置帮助链接及版权信息的地方。页脚自然是应该位于页面底部的，但依照一般的做法，如果位于页脚之前的网页内容比较少，或者说使用了一个垂直分辨率较大的显示器，就有可能出现页脚看起来不在页面底部的情况，如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/footer_distance.jpg&quot; title=&quot;页面内容不足的时候，页脚将不能贴到底部&quot; alt=&quot;页脚不能贴到底部&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于页脚基本上是一个网站的所有页面公用的部分，不同页面的内容量有所差异，因此确实有可能某些页面内容不够而出现这样的问题。另外，尤其是包含了底色的页脚，发生这种问题会很影响美观。&lt;/p&gt;

&lt;p&gt;所以，我们希望页脚能够&lt;em&gt;无论网页内容量多少，都准确地位于底部&lt;/em&gt;。&lt;/p&gt;

&lt;h2&gt;固定页脚到底部的方法&lt;/h2&gt;

&lt;h3&gt;绝对定位可行吗？&lt;/h3&gt;

&lt;p&gt;也许有人想到过把页脚设置为&lt;code&gt;position:fixed&lt;/code&gt;，然后定位在底部。先不考虑不支持这个属性值的IE6，从效果上说，如果网页本身内容就很充足，这样的写法就会让页脚一开始就出现在浏览器的底部，而在滚动网页时，页脚会一直保持原位置。这样的效果，显然对大部分的网站都是不适宜的。&lt;/p&gt;

&lt;p&gt;可以想见，我们需要的效果是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网页内容较多时，在滚动到底部的时候才看到位于最下方的页脚。&lt;/li&gt;
&lt;li&gt;网页内容较少时，页脚仍然位于整个页面的最下方，其余部分留白。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;常规、简单的实现方法&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://ryanfait.com/sticky-footer/&quot; title=&quot;A CSS Sticky Footer&quot;&gt;CSS Sticky Footer&lt;/a&gt;提供了这个固定页脚在底部的合理的实现方法。不过一方面这是一个英文站点，另一方面它所提供的写法还存在些许可以改善的地方，所以本文会参考它的内容，给出一个合理的实现方法。&lt;/p&gt;

&lt;p&gt;首先需要这样一个html结构：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;wrapper&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--网页内容--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;footer_placeholder&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;footer&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--页脚--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;div.wrapper&lt;/code&gt;是网页中除页脚之外的所有内容的外层容器，页脚&lt;code&gt;div.footer&lt;/code&gt;和它位于同一层级。&lt;code&gt;div.footer_placeholder&lt;/code&gt;必须放在网页所有内容的最后，即作为&lt;code&gt;div.wrapper&lt;/code&gt;的最后一个子元素，它的作用会在后文中说明。&lt;/p&gt;

&lt;p&gt;接下来写css，依次做说明。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当网页内容不足的时候，&lt;code&gt;body&lt;/code&gt;和&lt;code&gt;html&lt;/code&gt;的实际高度可能小于浏览器的可视范围，因此给&lt;code&gt;body&lt;/code&gt;和&lt;code&gt;html&lt;/code&gt;写上高度100%。此外，接下来的直接子元素也会使用百分比的写法，百分比的写法必须在直接父元素有确定的高度定义时才有效。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nc&quot;&gt;.wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;min-height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;margin-bottom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;/*假定页脚的高度为120px*/&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所有网页内容都在这个&lt;code&gt;div.wrapper&lt;/code&gt;中，定义最小高度（IE6使用hack），由于这个元素的父元素就是定义了100%高度的&lt;code&gt;body&lt;/code&gt;，因此无论内容多少，&lt;code&gt;div.wrapper&lt;/code&gt;这个元素的高度都会占据整个浏览器可视范围。然后，依照页脚的高度，设置相等的下边距负值，这样页脚就会恰好出现在页面内容的最后。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nc&quot;&gt;.footer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.footer_placeholder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;/*假定页脚的高度为120px*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;div.footer_placeholder&lt;/code&gt;，如字面意义，页脚的占位元素，它只是一个空的&lt;code&gt;div&lt;/code&gt;，定义高度和页脚相同，它的存在是为了给页脚留下位置。如果没有它，可能会发生这样的事情↓&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/footer_placeholder.jpg&quot; title=&quot;页脚占位符的作用&quot; alt=&quot;页脚占位符的作用&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到这里，&lt;em&gt;固定在底部的页脚就已经实现了&lt;/em&gt;。css部分合起来是：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;.wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;min-height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;margin-bottom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;/*假定页脚的高度为120px*/&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;.footer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.footer_placeholder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果还需要考虑css初始化和清理浮动，可能你还需要添加下面这部分css：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;margin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;.footer_placeholder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;both&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你现在正在看的本博客，就使用了本文的方法，以保证无论内容多少，页脚都能位于页面底部。我也觉得这是一个非常实用的方法！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>acgtofe博客建设完结纪念</title>
   <link href="http://acgtofe.com/posts/2013/03/acgtofe-complete"/>
   <updated>2013-03-12T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/03/acgtofe-complete</id>
   <content type="html">&lt;p&gt;到写下这段文字时，本博客也宣布初步完工。&lt;/p&gt;

&lt;p&gt;本博客的名字是acgtofe，如简介介绍的那样，我会在这里发布有关动漫、游戏、前端技术的博文，你也许看到了demo pages，这是我最开始构思博客的时候觉得可以加入的内容，字面意思理解的话，就是指实例，不过之后具体会是什么，我还在思考中，所以敬请期待。这也是为什么只说本博客是初步完工。&lt;/p&gt;

&lt;p&gt;说起来，把动漫和前端技术结合起来放在一起，还拼凑了这么一个名字，真是预想不到呢。ACG已经是一个很多人都知道的词了，而这个to虽然我是想说就是表示什么“和”什么，不过现在看来，单纯理解为英文介词to也不错...而FE所指的前端开发（Frond-End），相对来说就很少会有人知道了。这也难免，前端开发一词用作职业描述，已经算是比较新的事了。我自己则是前一段时间看国外的博文，偶然看到了这个词，然后查询了一下，才知道这个意思。有没有觉得，中文的翻译特别的直接？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/bookmark_start.jpg&quot; title=&quot;acgtofe博客建设完结纪念&quot; alt=&quot;acgtofe博客建设完结纪念&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“爱好ACG并从事web前端工作”，参考这样的描述，所以我做了这样的一个博客。希望本博客的内容，无论是对作为ACG同好的你，还是在从事前端工作的你，都能带来一些有用的信息，或者是有学习价值的知识，也或者是一点点的生活乐趣。&lt;/p&gt;

&lt;p&gt;本博客通过&lt;a href=&quot;http://jekyllbootstrap.com/&quot; title=&quot;Jekyll Bootstrap&quot;&gt;Jekyll Bootstrap&lt;/a&gt;搭建，如果你也对做这样的一个博客有兴趣，可以自己搜索相关的介绍信息及教程。&lt;/p&gt;

&lt;p&gt;博客建设完结，撒花！&lt;/p&gt;
</content>
 </entry>
 
 
</feed>