<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>acgtofe - 动漫与前端技术的综合博客</title>
 <link href="http://acgtofe.com/atom.xml" rel="self"/>
 <link href="http://acgtofe.com"/>
 <updated>2013-05-30T17:39:29+08:00</updated>
 <id>http://acgtofe.com</id>
 <author>
   <name>Liang Zhu</name>
   <email>kenanpengyou@gmail.com</email>
 </author>

 
 <entry>
   <title>像素与浏览器视口的细节</title>
   <link href="http://acgtofe.com/posts/2013/05/pixel-and-viewport"/>
   <updated>2013-05-31T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/05/pixel-and-viewport</id>
   <content type="html">&lt;p&gt;初学网页制作，很常见的做法就是找各种线上的网页，然后查看源代码，参考学习这些网页是如何实现自己的设计的。而对我来说，我印象最深的一个知识点，是这样的：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;wrapper&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nc&quot;&gt;.wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;980px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;margin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个在现在来看，其实就是经典的固定宽度的网页布局。不过，以前的时候，我并不知道为什么这样做就可以。当时的理解是：一个定宽，水平居中的容器，来容纳网页的主体内容，就可以使网页能在不同分辨率的显示屏都有相对较好的表现。而对于浏览器窗口这样一个摆放网页的“物件”，还有相当一些未理解的地方。&lt;/p&gt;

&lt;p&gt;网页布局并不只有这一种做法。不像这样简单地使用一个固定宽度的外层容器，同样可以做出在各种状况下都有较好表现的网页。不过，这种时候，就需要对页面布局原理有更深的了解，从而准确地控制好网页元素，保证按照预定的方式显示。&lt;/p&gt;

&lt;p&gt;本文将介绍像素及浏览器视口的概念，并解释说明与它们相关的，前端开发应理解的要点细节。本文主要参考了quirksmode.org上的&lt;a href=&quot;http://www.quirksmode.org/mobile/viewports.html&quot; title=&quot;A tale of two viewports&quot;&gt;A tale of two viewports&lt;/a&gt;，在这里非常推荐你也阅读一下（注意，这篇文章分为两部分）。&lt;/p&gt;

&lt;h2&gt;从像素开始&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;像素&lt;/em&gt;（&lt;em&gt;Pixel&lt;/em&gt;）是数字图像的最小组成单元，它不是一个物理尺寸，但和物理尺寸存在一个可变的换算关系（物理尺寸之间的换算是固定的）。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;PPI&lt;/em&gt;（&lt;em&gt;Pixel Per Inch&lt;/em&gt;）是指每英寸包含的像素数，同时也是针对这个换算关系的一个描述性指标。其中的英寸（Inch）和厘米（cm）、毫米（mm）等尺寸一样，都属于物理尺寸。不同的显示设备会有不同的PPI，因此，每一个像素点的物理尺寸（可以理解为你如果能拿刻度尺来量的话，得到的数值），也会因为设备的不同而存在差异。一般来说，越高的PPI，相当于在单位物理尺寸内用了更多、更小的像素点来显示图像，因此会更清晰。&lt;/p&gt;

&lt;p&gt;在Photoshop中，对图像大小的表示，有“像素大小”以及“文档大小”两个区域，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201305/photoshop_image_size.png&quot; title=&quot;Photoshop中的图像大小&quot; alt=&quot;Photoshop中的图像大小&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你也许注意过，这里无论改写哪个区域的数值，另一个区域的数字也会相应变化。因此，像素大小和文档大小只是在用不同的方式，表达同一图像的尺寸信息。任何时候，它们之间都可以用“分辨率”数值（比如这里是PPI）进行换算。&lt;/p&gt;

&lt;p&gt;与PPI类似的，还有一个&lt;em&gt;DPI&lt;/em&gt;（&lt;em&gt;Dot Per Inch&lt;/em&gt;），是指每英寸打印的点数，表示了打印机的打印精度，是属于印刷行业的概念。但如今随着数字化的输入输出设备的发展，很多人也把数字图像的解析度用DPI来表示。严格来说，印刷时计算的网点和电脑显示器的显示像素并不相同，但现在已普遍认同，数字图像显示屏的信息，用DPI或PPI表示均可行，是相同的含义。&lt;/p&gt;

&lt;h2&gt;设备像素与css像素&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;设备像素&lt;/em&gt;（&lt;em&gt;device pixels&lt;/em&gt;）是指与硬件设备直接相关的像素，是真实的屏幕设备中的像素点。比如说，一个电脑显示器的参数中，最佳分辨率是1920x1080，那么指的就是这个显示器在屏幕上用于显示的实际像素点，也就是设备像素。&lt;/p&gt;

&lt;p&gt;另一个概念是&lt;em&gt;css像素&lt;/em&gt;（&lt;em&gt;css pixels&lt;/em&gt;）。css像素是指网页布局和样式定义所使用的像素，也就是说，css代码中的px，对应的就是css像素。那么，css像素和设备像素有什么区别呢？简单地说，css像素比设备像素要更“虚拟”一些。下面来解释这一点。&lt;/p&gt;

&lt;p&gt;在桌面电脑上，浏览器有一个很少使用的功能：&lt;em&gt;缩放&lt;/em&gt;。比如下边这个矩形元素，宽度是128px，高度是40px。显然，这里的尺寸是css像素。&lt;/p&gt;

&lt;div class=&quot;post_display&quot;&gt;
    &lt;div style=&quot;width:128px;height:40px;background:#38a1ff;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;然后，缩放本页（&lt;code&gt;ctrl&lt;/code&gt; + &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;ctrl&lt;/code&gt; + &lt;code&gt;-&lt;/code&gt;），注意一下，你看到了什么？&lt;/p&gt;

&lt;p&gt;矩形元素的css像素尺寸没有变化，同样，你的显示器的设备像素尺寸也不会变化。但是，放大后，元素看起来变大了，在你的屏幕上占据了更大的空间。对应地，如果是缩小，则元素看起来变小了，在屏幕上占据的空间也变小了。&lt;/p&gt;

&lt;p&gt;css像素和设备像素之间是一种可变的转化关系。&lt;em&gt;在100%缩放比例下，1个css像素等于1个设备像素&lt;/em&gt;。在表示某一数目的css像素时，在放大状态下使用了更多的设备像素，而在缩小状态下使用了更少的设备像素。这就是css像素和设备像素的概念。&lt;/p&gt;

&lt;p&gt;对前端开发来说，设备像素没有意义，我只会关心css像素。只有css像素才描述了网页的布局与外观，我只需要让我的网页在100%缩放比例下看起来不错就可以了。&lt;/p&gt;

&lt;p&gt;在css中，大部分人都习惯于使用&lt;code&gt;px&lt;/code&gt;作为元素宽度或高度定义的单位。css中可也可以使用其他单位，比如&lt;code&gt;in&lt;/code&gt;英寸这样的物理尺寸单位。联系前文的内容，你一定会困惑这些单位的关系。css是这样做的：如果你使用&lt;code&gt;in&lt;/code&gt;这类物理尺寸，它会直接转化为css像素。这个转化关系是固定的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1in == 96px 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于css单位的详细内容，你可以阅读CSS-Tricks上的&lt;a href=&quot;http://css-tricks.com/the-lengths-of-css/&quot; title=&quot;The Lengths of CSS&quot;&gt;The Lengths of CSS&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;视口&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;视口&lt;/em&gt;（&lt;em&gt;viewport&lt;/em&gt;），指的是浏览器窗口中用来显示网页的区域。以桌面电脑的浏览器来说，就是浏览器窗口除去标题栏，菜单栏，地址栏，状态栏等等浏览器的“周边”的东西后剩余的区域。&lt;/p&gt;

&lt;h3&gt;桌面电脑中的视口&lt;/h3&gt;

&lt;p&gt;桌面电脑中的视口，一般来说是这样的印象：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201305/viewport_on_desktop.jpg&quot; title=&quot;桌面电脑中的视口&quot; alt=&quot;桌面电脑中的视口&quot; /&gt;&lt;/p&gt;

&lt;p&gt;视口是存在着一些特性的，要讨论它，就要分析&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;这两个元素。&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;是任何网页都必然存在的元素，但它们的表现及特性却很少被提及。现在，通过一个例子来说明。&lt;/p&gt;

&lt;p&gt;假设&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;有一个做自适应布局的直接子元素，比如说侧边栏，定义了&lt;code&gt;width:20%&lt;/code&gt;，然后调整浏览器窗口大小，你会看到元素会相应做尺寸调整（如果你用前端工具查看，可以看到元素的宽度的计算值，也即css像素，是变化的），始终在视口中占据20%的宽度（这里也假定所有元素都没有内外边距和边框）。这是如何做到的？&lt;/p&gt;

&lt;p&gt;可以想到，侧边栏的20%是取了父级元素，也就是&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;的宽度值。那&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;有多宽呢（没有给它定义宽度）？显然，&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;作为块元素，会取父元素，也就是&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;的100%宽度值。最后一个问题，&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;有多宽？是的，同样，&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;作为块元素，会再依照一个宽度值取100%，这个宽度值就是视口的宽度。&lt;/p&gt;

&lt;p&gt;因此，可以理解为，视口表现得像是&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;之上的一个块元素，它限制并确定&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;的宽度，但却不属于html结构，不能被设置样式。而且，任何时候，视口的尺寸都会随着浏览器窗口的大小变化而变化。桌面电脑中的视口，就是这样的一个概念。&lt;/p&gt;

&lt;p&gt;也许，你见过这样的问题：在全屏状态下看起来不错的网页，如果调整为一个比较小的浏览器窗口，然后再在这个时候拖动一下横向的滚动条，就会有不协调的地方。比如下图这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201305/viewport_trouble.jpg&quot; title=&quot;较小的视口时有可能存在的问题&quot; alt=&quot;较小的视口时有可能存在的问题&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，联系一下视口与网页中的元素之间的显示关系，就可以知道原因了。在这样浏览器窗口较小的时候，视口较小，&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;也受视口影响，宽高变得比较小，而带背景图或背景色的元素是取父元素的100%宽度，因此，会只有这样的宽度。&lt;/p&gt;

&lt;p&gt;这里会出现问题，也是因为有其他网页元素定义的宽度超过了此时的&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;的宽度，从而使一部分元素在水平方向上出现在了视口之外。如果要解决这个问题，为带背景图或背景色的元素，定义一个最小宽度即可。&lt;/p&gt;

&lt;h3&gt;手机中的视口&lt;/h3&gt;

&lt;p&gt;相比桌面电脑，在手机上浏览网页，最大的差异在于屏幕尺寸。如果你拿手机来看一个平时用桌面电脑浏览的网页，那么一定会经历下面两种状态：页面被缩小，以至于文字无法阅读，或者处于适中的缩放比例，但只显示了整个网页的一小部分。&lt;/p&gt;

&lt;p&gt;手机浏览器的供应商致力于让用户在手机上也获得最佳的网页浏览体验，这也是说，要让手机浏览网页的体验能够“尽可能地和桌面电脑相同”。&lt;/p&gt;

&lt;p&gt;然后，手机浏览器的供应商是这么考虑的：由于手机屏幕的宽度对于css网页布局来说太小，为了让更多的网页能正常显示（一些流体布局的网页会在过窄的视口中变得一团乱），应该让视口更宽，超越屏幕的宽度。所以，在手机浏览器中，视口被划分为了两个：&lt;em&gt;可见视口&lt;/em&gt;（&lt;em&gt;visual viewport&lt;/em&gt;）和&lt;em&gt;布局视口&lt;/em&gt;（&lt;em&gt;layout viewport&lt;/em&gt;）。&lt;/p&gt;

&lt;p&gt;可见视口是指当前在手机屏幕上显示的部分。当你做缩放的时候，可见视口的尺寸（css像素值）也会变化。如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201305/visual_viewport_on_mobile.jpg&quot; title=&quot;手机上的可见视口&quot; alt=&quot;asdasd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和可见视口不同，布局视口用于元素布局和尺寸计算（比如百分比的宽度值），而且比可见视口明显要更宽。无论你缩放，或者滑动页面，甚至翻转手机屏幕，布局视口始终不变。前文介绍过&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;元素会取视口的宽度值，在手机上，这个限定和确定&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;的是布局视口。这就是手机浏览器在处理时和桌面电脑浏览器不一样的地方，而这个布局视口的引入，保证了网页在手机里中的显示与在桌面电脑上的一致。&lt;/p&gt;

&lt;p&gt;布局视口的宽度是由手机浏览器定义的，随浏览器不同而不同。比如Safari是980px，Android   Webkit是800px。这都远比屏幕宽度值要大。&lt;/p&gt;

&lt;p&gt;你可以做一个测试：写一个整体只有300px宽的网页，但不针对手机做任何处理（也就是代码写法和桌面电脑网页一样），然后用手机打开。你会看到，即使页面内容没有超过手机屏幕宽度，页面仍然会被大比例缩小，就好像这个页面“是一个很宽的桌面电脑网页”。这个测试可以说明布局视口的存在。&lt;/p&gt;

&lt;h3&gt;更改手机中的布局视口&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;手机中的布局视口是可以更改的&lt;/em&gt;。你一定在很多移动版网页中见到过下边这个&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签元素。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;viewport&amp;quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是最早由Safari引入，但如今已普遍被各类手机浏览器认可了的一项设置。这其中有一句&lt;code&gt;width=device-width&lt;/code&gt;，它的意思是，把手机浏览器的布局视口的宽度，更改为当前设备的宽度。你还可以使用&lt;code&gt;width=500&lt;/code&gt;这样的具体数值（也是css像素值）。总的来说，使用这个&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签元素，就可以告诉手机浏览器当前页面应该使用的布局视口的尺寸。&lt;/p&gt;

&lt;p&gt;关于这个viewport meta tag的更多信息，你可以阅读Mozilla开发团队写过的[关于viewport meta tag的文章][]。&lt;/p&gt;

&lt;h2&gt;与媒体查询的关系&lt;/h2&gt;

&lt;p&gt;css中的&lt;code&gt;@media&lt;/code&gt;媒体查询可以根据尺寸信息分别定义不同的css。其中，可用的值有2个，&lt;code&gt;width/height&lt;/code&gt;和&lt;code&gt;device-width/device-height&lt;/code&gt;。这两种尺寸信息有什么区别呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;width/height&lt;/code&gt;使用的是视口的尺寸值，如果是手机，则是布局视口的尺寸值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;device-width/device-height&lt;/code&gt;使用的是设备屏幕的尺寸值。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在桌面电脑上，如果你写：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;k&quot;&gt;@media&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;max-width&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;:600px&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/*特定样式，只在宽度不大于600时有效*/&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么，只需要调整浏览器尺寸到一定程度，你就可以看到这部分特定样式生效后的效果。但是，如果把这里的&lt;code&gt;max-width&lt;/code&gt;换成&lt;code&gt;max-device-width&lt;/code&gt;，那么，无论做什么，都无法看到这部分特定样式生效，因为整个显示器的宽度是不会变化的。因此，在桌面电脑上，你只需要使用&lt;code&gt;width&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而在手机上，如果网页有前面说的&lt;code&gt;width=device-width&lt;/code&gt;的定义（目前几乎所有移动版网页都做了这样的定义），那么使用&lt;code&gt;width&lt;/code&gt;和&lt;code&gt;device-width&lt;/code&gt;是相同的。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;由像素及浏览器视口引入的相关知识还有不少，本文受限于篇幅（如果太长了我实在觉得不能拿来看...（ ﾟ口ﾟ）），只以尽可能明确的方式，介绍了主要的部分。如果有任何疑惑的地方，欢迎讨论。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>css进阶 - 从选择符开始</title>
   <link href="http://acgtofe.com/posts/2013/05/better-css-selectors"/>
   <updated>2013-05-20T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/05/better-css-selectors</id>
   <content type="html">&lt;p&gt;在我最早开始写css的时候，其代码上的高自由度就一直很令我困惑。这就是说，同一个设计，如果让不同的人来实现，最终的代码一定是有差异的。但这存在一个问题，如果不同的人通过不同的方法以及代码风格，都从外观上实现了一样的设计，将很难评价谁做得更好。想来也是，既然都实现了设计，达到了目的，css这种没有程序逻辑的代码中，又能找出什么来说明谁做得更出色呢？&lt;/p&gt;

&lt;p&gt;而如今，我认同的观念是，css这种描述性语言，仍然有着代码上的质量评判。评判标准就是&lt;em&gt;可维护性&lt;/em&gt;（&lt;em&gt;Maintainability&lt;/em&gt;）和&lt;em&gt;性能&lt;/em&gt;（&lt;em&gt;Performance&lt;/em&gt;），用比较通俗的话说，好的css，要对开发者的工作友好（dev-friendly），也要对浏览器友好（browser-friendly）。 本文将说明如何从css选择符的角度来提高css代码质量。&lt;/p&gt;

&lt;h2&gt;关键选择符与浏览器的样式规则匹配原理&lt;/h2&gt;

&lt;p&gt;css选择符的概念，在之前的&lt;a href=&quot;http://acgtofe.com/posts/2013/04/css-specificity-explain-in-detail/&quot; title=&quot;css优先级详细解析&quot;&gt;css优先级详细解析&lt;/a&gt;的开头部分也有提到，是指每一条样式规则中，描述把样式作用到哪些元素的部分，也即&lt;code&gt;{}&lt;/code&gt;之前的部分。在本文，还要额外介绍一个概念：&lt;em&gt;关键选择符&lt;/em&gt;（&lt;em&gt;Key selector&lt;/em&gt;）。关键选择符就是在每一条样式规则起始的&lt;code&gt;{&lt;/code&gt;之前的最后一个选择符，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201305/key_selector_explain.png&quot; title=&quot;css关键选择符&quot; alt=&quot;css关键选择符&quot; /&gt;&lt;/p&gt;

&lt;p&gt;css选择符将确定后面的属性定义要作用到哪些元素,因此存在一个浏览器根据css选择符来应用样式到对应元素的匹配过程。关于浏览器的样式匹配系统，David Hyatt在&lt;a href=&quot;http://www.mozilla.org/xpfe/goodcss.html&quot; title=&quot;Writing Efficient CSS&quot;&gt;Writing Efficient CSS for use in the Mozilla UI&lt;/a&gt;一文中提到了以下内容：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The style system matches a rule by starting with the rightmost selector and moving to the left through the rule’s selectors. As long as your little subtree continues to check out, the style system will continue moving to the left until it either matches the rule or bails out because of a mismatch.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;意思是说，浏览器引擎在样式匹配时，以&lt;em&gt;从右向左&lt;/em&gt;的顺序进行。在具体匹配某一条样式规则时，这个从右向左的过程会一直持续，直到读取完整个选择符序列并完成匹配，或因某一个地方的不匹配而取消（然后转到另一条样式规则）。&lt;/p&gt;

&lt;p&gt;至于为什么浏览器会选择这样的匹配顺序，你可以看看&lt;a href=&quot;http://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left&quot; title=&quot;Why do browsers match CSS selectors from right to left?&quot;&gt;Stack Overflow上的相关讨论&lt;/a&gt;。大致上解释一下的话，由于最右边的关键选择符直接表示了样式定义应作用的元素，所以从右向左的顺序更利于浏览器在初始匹配的时候就确定有样式定义的元素集合，并更快地在找某一个元素的样式时避开大多数实际没有作用到的选择符。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;更好的css选择符，是让浏览器在样式匹配过程中减少匹配查询次数，以更快的速度完成样式匹配，从而优化前端性能&lt;/em&gt;。这其中，也必须参考浏览器的对于样式从右向左的匹配顺序。&lt;/p&gt;

&lt;h2&gt;css选择符的正确使用方式&lt;/h2&gt;

&lt;h3&gt;更特定，更具体的关键选择符&lt;/h3&gt;

&lt;p&gt;关键选择符是浏览器引擎在样式匹配时最先读取到的部分，因此，如果你在某一条样式规则中使用更特定、具体的选择符，可以帮助减少浏览器的查找匹配次数。&lt;/p&gt;

&lt;p&gt;比如说下边这样的选择符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.content .note span{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一个&lt;code&gt;span&lt;/code&gt;是关键选择符，而&lt;code&gt;span&lt;/code&gt;这个标签，在网页中使用是非常多的。浏览器从&lt;code&gt;span&lt;/code&gt;开始读取选择符，就可能会为因此在样式匹配上做了一些额外工作。&lt;/p&gt;

&lt;p&gt;如果你确定只是想为具体处于那一个位置的&lt;code&gt;span&lt;/code&gt;元素定义样式，更好的做法是为&lt;code&gt;span&lt;/code&gt;命名class，比如命名为&lt;code&gt;span.note_text&lt;/code&gt;，然后简单写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.note_text{}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;使用class选择符&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;class选择符（类选择符）是最利于性能优化的选择符&lt;/em&gt;。相对于class，ID的缺点是只允许定义给一个元素，无法重用。而此外，它在使用上没有任何比class更好的地方。很多时候，你很难确定某一个元素是否是唯一的。另外，使用class来定义样式，而保留ID给javascript，一直是一个较好的实践。如果可以，不使用ID来定义样式。&lt;/p&gt;

&lt;p&gt;而相对于class，标签在html中的重复性要更大，因此同样可能让浏览器在样式匹配时做更多的额外工作。如果可以，除css样式清零（reset）外，不使用标签选择符（也叫元素选择符）。&lt;/p&gt;

&lt;h3&gt;缩短选择符序列&lt;/h3&gt;

&lt;p&gt;继承写法（准确地说，这里指css关系选择符中的包含选择符）是css中很常用的写法。继承写法的初衷是，如果有两个元素，都是同样的标签或有相同的class命名，加入父元素的选择符组成选择符序列，就可以避免在不需要的时候两个元素的样式互相影响。比如&lt;code&gt;.confirm_layer .submit_btn&lt;/code&gt;就是指，class名为&lt;code&gt;submit_btn&lt;/code&gt;，且有一个class名为&lt;code&gt;confirm_layer&lt;/code&gt;的父元素的元素，才应用样式。&lt;/p&gt;

&lt;p&gt;但是，避免元素样式相互影响，并不代表可以随意地使用继承选择符。前面提到，浏览器会从右向左读取整个选择符序列，直到读取完毕并匹配完成，或者因不匹配而取消。因此，&lt;em&gt;短的选择符序列更有利于浏览器更快地完成匹配过程&lt;/em&gt;。相对的，冗长的选择符序列则认为是低效的，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.header ul li .nav_link{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.header .nav_link{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来说，不超过3层的继承层级就可以满足实际中的开发要求。因此，应减少不必要的继承层级，使用更短的选择符序列。&lt;/p&gt;

&lt;p&gt;此外，较长的选择符序列还有一个问题。有较长选择符的样式规则，css优先级的计算值也较大，因此，如果在以后需要写新的样式来覆盖掉它，就需要写更长的选择符（或者使用ID）以获得更高的css优先级。这对性能和代码可读性都是不利的。&lt;/p&gt;

&lt;h3&gt;避免链式选择符&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;链式选择符&lt;/em&gt;（&lt;em&gt;Chaining selectors&lt;/em&gt;）是对单个元素同时写了多个选择符判定的情况。比如&lt;code&gt;p.name&lt;/code&gt;是指class名为&lt;code&gt;name&lt;/code&gt;，且标签是&lt;code&gt;p&lt;/code&gt;的元素，才应用样式。这些判定组合可以是ID选择符，标签选择符，class选择符的任意组合。&lt;/p&gt;

&lt;p&gt;但是，链式选择符是过度定义（over qualified）的，不利于重用，也不利于性能优化。如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a#author{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#author{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;a&lt;/code&gt;是不必要的。一个ID只对应一个元素，没有必要再强调这个元素的标签是什么（同理，class也不必）。另外有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.content span.arrow{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.content .arrow{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;span.arrow&lt;/code&gt;中的&lt;code&gt;span&lt;/code&gt;也是不必要的。一方面，这为浏览器在样式匹配时增加了一项额外工作：检查class名为&lt;code&gt;arrow&lt;/code&gt;的元素的标签名是不是&lt;code&gt;span&lt;/code&gt;，也因此降低了性能。另一方面，如果去掉了这个限定，&lt;code&gt;.arrow&lt;/code&gt;的样式定义，就可以用在更多的元素上，也就有着更好的重用性。否则，就还得告诉别人，使用这个的时候只能用在&lt;code&gt;span&lt;/code&gt;标签上。&lt;/p&gt;

&lt;p&gt;同理，多个class的链式写法，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.tips.succuss{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议更改命名，写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.tips_succuss{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样可以帮助浏览器减少额外的样式匹配工作。&lt;/p&gt;

&lt;p&gt;此外，IE6还存在一个链式选择符的问题，多个class选择符写在一起时，例如&lt;code&gt;.class1.class2.class3&lt;/code&gt;，正常情况是只有同时有这全部的class的元素，才应用样式。但IE6只认最后一个，也就是符合&lt;code&gt;.class3&lt;/code&gt;这个选择符的元素，就应用样式。&lt;/p&gt;

&lt;h2&gt;例外情况&lt;/h2&gt;

&lt;p&gt;前面所述的选择符的写法的建议，只是从浏览器渲染性能优化，及代码的重用性方面分析得到的理论结果。在实际使用中，你并不需要严格按照这些内容来做。例如，如果你确实是准备为class名为&lt;code&gt;intro&lt;/code&gt;的元素内的所有&lt;code&gt;a&lt;/code&gt;标签元素都加上某样式，那么&lt;code&gt;.intro a&lt;/code&gt;这样的选择符是明智的。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;关于高效的css选择符的指南，你还可以阅读google developer中的&lt;a href=&quot;https://developers.google.com/speed/docs/best-practices/rendering#UseEfficientCSSSelectors&quot; title=&quot;Use efficient CSS selectors&quot;&gt;Use efficient CSS selectors&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如今，现代浏览器在样式匹配上也逐渐有了更多的优化（参考&lt;a href=&quot;http://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/&quot; title=&quot;CSS Selector Performance has changed! (For the better)&quot;&gt;CSS Selector Performance has changed!&lt;/a&gt;），有些方面的内容我们已经不再需要再担心了。但是，这并不意味着不需要考虑写合理的css选择符了。css选择符性能优化是依然存在的事，你的选择符应该更好地体现你的意图，而不是随心所欲地使用。更重要的是，以这样一种稍细腻的，经过思考的想法来写css选择符，并不是一件困难的事。只要你想，形成这样的一种习惯，你就可以自然地在这方面做得更好，何乐而不为呢？&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>css优先级详细解析</title>
   <link href="http://acgtofe.com/posts/2013/04/css-specificity-explain-in-detail"/>
   <updated>2013-04-21T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/04/css-specificity-explain-in-detail</id>
   <content type="html">&lt;p&gt;css不是一种程序语言，而是一种描述语言。因此，可以说，css理解起来是非常容易的，大部分人通过简单的学习就可以懂得如何写css代码来定义网页的样式。但是，大部分人同样也会在写css的过程中产生很多困惑，比如为什么自己写的某段css没有生效，或者呈现出的样式和预计的不同，但又不知道要如何解决。&lt;/p&gt;

&lt;p&gt;造成这些问题的主要因素，是&lt;em&gt;css优先级&lt;/em&gt;。css优先级是css中最难理解的概念之一，但对于掌握css来说非常重要。理解css优先级，不仅有利于快速解决样式问题，而且能在布局层面，帮助我们写出更明晰，更合理的css代码。&lt;/p&gt;

&lt;h2&gt;什么是css优先级&lt;/h2&gt;

&lt;p&gt;css的组成单元是&lt;em&gt;样式规则&lt;/em&gt;（&lt;em&gt;CSS Rule&lt;/em&gt;），单条样式规则的形式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/css_rule_explain.png&quot; title=&quot;样式规则&quot; alt=&quot;样式规则&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，&lt;em&gt;选择符&lt;/em&gt;（&lt;em&gt;Selector&lt;/em&gt;）决定了后边所写的属性定义会作用到哪些元素，因此称为选择符。&lt;/p&gt;

&lt;p&gt;css有一个核心特性，当多条样式规则中的同一个属性（比如&lt;code&gt;padding&lt;/code&gt;）作用到了同一个元素，这些样式之间就会发生覆盖：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/undoing_style_example.png&quot; title=&quot;css样式覆盖示意&quot; alt=&quot;css样式覆盖示意&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中由前端调试工具所显示的，被划掉的css样式，不会呈现在这里选中的网页元素上，因为它们被覆盖掉了。css优先级，就是指在这种情况下，得出“应该由哪一条样式规则的内容覆盖掉其他的”这个结论的过程中所遵循的原则。更一般的表述是，&lt;em&gt;优先级高的css样式，将覆盖优先级低的css样式，成为最终网页元素的实际样式&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;注意，前端调试工具显示的，”被划掉“的css样式，并不是说一定是完全覆盖。css中的一些组合属性（比如&lt;code&gt;margin&lt;/code&gt;，可以拆分为&lt;code&gt;margin-top&lt;/code&gt;、&lt;code&gt;margin-right&lt;/code&gt;、&lt;code&gt;margin-bottom&lt;/code&gt;、&lt;code&gt;margin-left&lt;/code&gt;），在这种样式覆盖中遵循的是局部覆盖的原则，即使在前端调试工具中它们看起来“整个都被划掉了”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/rollup_property_overwrite.png&quot; title=&quot;组合属性覆盖&quot; alt=&quot;组合属性覆盖&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;css优先级的影响因素&lt;/h2&gt;

&lt;p&gt;css优先级的影响因素要考虑三部分内容，&lt;em&gt;css选择符权重&lt;/em&gt;、&lt;em&gt;!important标识符&lt;/em&gt;、&lt;em&gt;属性继承&lt;/em&gt;。很多文章都阐述过css选择符权重这一点，但后面两部分却很少被提及。本文会依照这三部分做详细的说明。&lt;/p&gt;

&lt;h2&gt;属性继承&lt;/h2&gt;

&lt;p&gt;css中一部分属性是&lt;em&gt;可继承属性&lt;/em&gt;，比如文本颜色&lt;code&gt;color&lt;/code&gt;。css优先级的讨论，首先应认清css中的属性继承所带来的影响。由于存在可继承属性，一个网页元素的样式来源可以分为两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由css选择符直接定义到元素&lt;em&gt;本身&lt;/em&gt;的样式。&lt;/li&gt;
&lt;li&gt;css选择符未作用到，但&lt;em&gt;继承&lt;/em&gt;自父级元素的样式。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;em&gt;定义到元素本身的样式，包括浏览器默认样式，一定比继承得到的样式优先级高&lt;/em&gt;。因此，可以这样认定：继承得到的样式的优先级是最低的，在任何时候，只要元素本身有同属性的样式定义，就可以覆盖掉继承值：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/inherit_property_overwrite.png&quot; title=&quot;可继承属性覆盖&quot; alt=&quot;可继承属性覆盖&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而且，继承样式是最低优先级这一点，是&lt;em&gt;无视继承样式所在的样式规则的内容&lt;/em&gt;的。这就是说，继承样式所在的样式规则，即使其选择符的权重比元素本身样式的选择符的权重更高（本文后文会介绍选择符权重~ :) ），甚至继承样式被写了&lt;code&gt;!important&lt;/code&gt;，继承样式会被元素本身样式覆盖这一点仍然成立。&lt;/p&gt;

&lt;p&gt;举例来说明。下面这段html：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;container&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;note_text&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;acgtofe - 动漫与前端技术的综合博客&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对应的css：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nf&quot;&gt;#container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;darkblue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;.note_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;darkorange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个部分在所有浏览器中的效果都是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/inherit_regardless_of_selector_specificity.png&quot; title=&quot;继承属性优先级原则无视选择符权重&quot; alt=&quot;继承属性优先级原则无视选择符权重&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再为原来的css增加&lt;code&gt;!important&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nf&quot;&gt;#container&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;darkblue&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;!important&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;.note_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;darkorange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，会发现所有浏览器中的效果都不变：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/inherit_regardless_of_important.png&quot; title=&quot;继承属性优先级原则无视!important&quot; alt=&quot;继承属性优先级原则无视!important&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当一个元素有多个父级元素都定义了继承样式，这些继承样式之间的优先级又是怎样的？这时候，遵循的优先级原则可以叫做&lt;em&gt;就近原则&lt;/em&gt;，也就是说，&lt;em&gt;在存在多个继承样式时，层级关系距离当前元素最近的父级元素的继承样式，具有相对最高的优先级&lt;/em&gt;。同样，这时候也是无视样式规则内容的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/multiple_inherit.png&quot; title=&quot;多个继承属性时的优先级&quot; alt=&quot;多个继承属性时的优先级&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就近原则其实不算是新的结论，想一下，如果把每一个父级元素都作为当前元素，然后按照前边的“元素本身样式大于继承样式”的原则推理一遍，就可以明白，离得最近的父级元素的继承样式优先级最高，是很合理的。&lt;/p&gt;

&lt;h2&gt;css选择符权重&lt;/h2&gt;

&lt;p&gt;css选择符权重是css优先级的核心概念。但在考虑css选择符权重前，请记住，这条优先级原则涉及的样式都是指&lt;em&gt;定义在元素本身的样式&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;每一条样式规则的选择符，除了决定这条样式规则会作用到哪些元素之外，选择符也是浏览器判断css规则优先级的参考信息。css选择符权重不是简单的内容，但却可以用简单而直观的方法做阐述。&lt;/p&gt;

&lt;p&gt;css选择符权重是一个数字游戏，比的就是谁的计算值更大。&lt;em&gt;权重计算值大的样式规则将有更高的优先级&lt;/em&gt;。你可以想象为龙珠里的战斗力测量，在这场权重战争（&lt;a href=&quot;http://www.stuffandnonsense.co.uk/archives/css_specificity_wars.html&quot; title=&quot;CSS: Specificity Wars&quot;&gt;Specificity Wars&lt;/a&gt;，这也是早期的一篇阐述css优先级的文章中用到的词）中，战斗力最强的将取得胜利。&lt;/p&gt;

&lt;p&gt;战斗力的测量方法是统计选择符中的不同组成元素的个数，并以 (a,b,c,d) 这种形式来判断。其中，abcd分别代表了不同类别的选择符组成元素，且战斗力分别在不同的数量级，a最强，d最弱。从弱到强，这4个字母分别代表的类别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;元素选择符（Element），伪元素选择符（Pseudo Element） d = 1 – (0,0,0,1)&lt;/li&gt;
&lt;li&gt;类选择符 （Class），伪类选择符（Pseudo class），属性选择符（Attribute） c = 1 – (0,0,1,0)&lt;/li&gt;
&lt;li&gt;Id选择符 b = 1 – (0,1,0,0)&lt;/li&gt;
&lt;li&gt;内联样式（Inline style） a = 1 – (1,0,0,0)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这里的&lt;em&gt;伪元素&lt;/em&gt;和&lt;em&gt;伪类&lt;/em&gt;做一下补充说明。伪元素选择符，指的是样式作用到的元素不是html结构中的实际元素，即不是真正的dom元素。目前只有&lt;code&gt;:before&lt;/code&gt;，&lt;code&gt;:after&lt;/code&gt;，&lt;code&gt;:first-line&lt;/code&gt;，&lt;code&gt;:first-letter&lt;/code&gt;和&lt;code&gt;::selection&lt;/code&gt;这5个伪元素选择符。伪类选择符，则是指除前边的这部分选择符之外，在css中加入冒号&lt;code&gt;:&lt;/code&gt;的，用于实现动态效果与智能控制的选择符，比如&lt;code&gt;:hover&lt;/code&gt;，&lt;code&gt;:nth-of-type(n)&lt;/code&gt;。从css3开始，通过区别使用双冒号&lt;code&gt;::&lt;/code&gt;来表示伪元素，单冒号&lt;code&gt;:&lt;/code&gt;来表示伪类，但为了和以前的浏览器兼容，&lt;code&gt;:after&lt;/code&gt;这种诞生于css2的伪类选择符仍然允许使用单冒号的写法。&lt;/p&gt;

&lt;p&gt;现在，可以找一些css选择符计算一下了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/specificity_calculate_example.png&quot; title=&quot;css选择符权重计算举例&quot; alt=&quot;css选择符权重计算举例&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看过这些例子后，请理解为，简单的分类计数，正是css中的战斗力测量方法。(a,b,c,d) 这种形式中，abcd分别是不同的数量级，a&gt;b&gt;c&gt;d，和数字的大小比较方法相同，从高位开始，如果高位数字相同，则取低一位数字比较，以此类推。&lt;em&gt;选择符权重计算值最大的样式规则中的属性，覆盖其他的样式规则中的同名属性&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;如果你觉得自己计算麻烦，请到&lt;a href=&quot;http://specificity.keegan.st/&quot; title=&quot;Specificity Calculator&quot;&gt;Specificity Calculator&lt;/a&gt;，这是一个非常棒的计算器。&lt;/p&gt;

&lt;p&gt;(a,b,c,d) 中，a代表的内联样式实际是存在于html代码中，只能取值为0或1，所以和其他的较为不同。后边的bcd虽说是不同的数量级，但详细说来有多大差距呢？请看下面这一段&lt;a href=&quot;http://hg.mozilla.org/mozilla-central/file/17c65d32c7b8/layout/style/StyleRule.cpp#l521&quot; title=&quot;mozilla-central source&quot;&gt;Firefox浏览器源代码&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/firefox_css_selector_source.png&quot; title=&quot;Firefox浏览器源代码-StyleRule&quot; alt=&quot;Firefox浏览器源代码-StyleRule&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出，class和id对应的十六进制数值之间隔了2位，所以，在Firefox中，要256（16&lt;sup&gt;2&lt;/sup&gt;）个class才相当于1个id。在不同浏览器中，这种层级差距，可能有所不同。在写本文的时间点，Opera和Chrome中用256+的class也不能大于id的权重。不过，这些细节信息并不重要，你在实际使用中不可能用到这个数量的选择符。所以，应认为前面所述的权重计算方法是可靠的。&lt;/p&gt;

&lt;p&gt;如果权重计算值相同，则进入后一个环节：样式定义顺序。&lt;/p&gt;

&lt;h3&gt;样式定义顺序&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;权重计算值相同的样式规则，定义顺序靠后的优先级高&lt;/em&gt;。这里的定义顺序，包含了所有的静态样式（不包括由javascript创建&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;元素引入的样式）定义的可能情况。如直接写在html的&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;标签内的样式规则，通过&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;引入的css文件，以及&lt;code&gt;@import&lt;/code&gt;引入的css文件。&lt;/p&gt;

&lt;p&gt;请记住，只有权重计算值相同的时候，你才需要考虑样式定义顺序。&lt;/p&gt;

&lt;h2&gt;!important标识符&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;!important&lt;/code&gt;是可以写在样式规则中的某一属性定义值后的标识符，用于提升某一属性的样式定义的优先级。不同于决定整条样式规则优先级的css选择符权重，&lt;code&gt;!important&lt;/code&gt;只影响自己所在位置的单一属性。&lt;code&gt;!important&lt;/code&gt;在优先级原则中，可以理解为前文的(a,b,c,d)结构中的，比a更高位的标识：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/position_of_css_important.png&quot; title=&quot;!important在优先级原则中的位置&quot; alt=&quot;!important在优先级原则中的位置&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后，你完全再按照前文的css选择符权重的比较方法，就可以得出在这种情况下的css优先级了。具体说的话，可以表述如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写有&lt;code&gt;!important&lt;/code&gt;标识符的样式，其优先级一定大于没有该标识符的样式。&lt;/li&gt;
&lt;li&gt;在都写有&lt;code&gt;!important&lt;/code&gt;标识符的样式之间，再按照一般的css选择符权重的优先级原则做判断。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;css优先级的浏览器兼容性&lt;/h2&gt;

&lt;p&gt;css优先级虽然是不简单的内容，但幸运的是，除IE6和IE7存在少量优先级的bug（详见&lt;a href=&quot;http://www.brunildo.org/test/IEASpec.html&quot; title=&quot;IE Specificity bugs&quot;&gt;IE Specificity bugs&lt;/a&gt;）外，几乎所有浏览器都很一致地遵循css优先级原则。所以，css优先级是很通用的概念，可以在各种情况下应用而不必担心兼容性。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;css优先级的概念在本文就介绍到此。本文所阐述的仍有不够全面的地方，如果你碰到一些新的问题，欢迎来这里讨论。在实际应用中，理解css优先级并不是让我们去这样分析每一条样式规则，而只是让我们有一个更清醒的状态，知道如何去布局和控制自己所写的css。所谓“知己知彼，百战不殆”，也是这样的道理。&lt;/p&gt;

&lt;p&gt;css全名是层叠样式表（Cascading Style Sheet），css优先级正是这种“层叠”中所遵循的原则，由此也可以看出css优先级的重要性。最后，以一个自制的图来结尾：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/special_card_css_specificity_war.jpg&quot; title=&quot;CSS Specificity War&quot; alt=&quot;CSS Specificity War&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Love Live! ED 主题曲 - きっと青春が聞こえる</title>
   <link href="http://acgtofe.com/posts/2013/04/lovelive-ed"/>
   <updated>2013-04-14T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/04/lovelive-ed</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201304/lovelive_ed_cd_cover.jpg&quot; title=&quot;Love Live! ED - きっと青春が聞こえる&quot; alt=&quot;Love Live! ED - きっと青春が聞こえる&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;post_display&quot; style=&quot;height:24px;&quot;&gt;
    &lt;audio src=&quot;http://Boplink.tk/?shareid=476255&amp;uk=3607508940.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;
&lt;/div&gt;


&lt;p&gt;歌词（自译）&lt;/p&gt;

&lt;p&gt;&lt;small&gt;素直に追いかけて　勇気で追いかけて〖坦率地去追寻　以勇气去追寻〗&lt;br/&gt;
小さな願いが明日を作る〖小小的愿望化作明天〗&lt;br/&gt;
できるかも　みんなが望むなら〖只要大家期望　就能够做到〗  &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;誰より頑張っちゃえ　とにかく情熱のままに〖比谁都更努力　保持满腔的热情〗&lt;br/&gt;
目指すのは綺麗な風吹く道〖以那美丽的　风吹着的道路为目标〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;羽のように　腕あげて〖像展翅一样张开双臂〗&lt;br/&gt;
まぶしい未来へと飛ぶよ〖向那灿烂的未来飞去〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;きっと青春が聞こえる　その瞬間に聞こえる〖一定能听到青春的音符　就在那个瞬间〗&lt;br/&gt;
笑顔ならいつの日も大丈夫！〖保持微笑的话　每天都能过得愉快〗&lt;br/&gt;
きっと青春が聞こえる　その瞬間が見たいね〖一定能听到青春的音符　想要见证那个瞬间〗&lt;br/&gt;
となりに君がいて(嬉しい景色)〖你就在我身旁(令人高兴的景色)〗&lt;br/&gt;
となりは君なんだ〖我的身旁就是你〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;素顔で会いたいよ　元気に会いたいよ〖想素颜相见　想充满活力地相见〗&lt;br/&gt;
きらきら流れる陽射しの元で〖灿烂地照耀着的阳光下〗&lt;br/&gt;
話すのは　みんなのこれからさ〖要说的　是大家从今以后的事〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;誰かが言ってたよ　自分を信じれば叶う〖有人说过　相信自己就可以实现愿望〗&lt;br/&gt;
わかるかも奇跡はつかめるはず〖也许理解的话就可以发生奇迹〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;悔しさを　受けとめて〖所有的后悔　都接受〗&lt;br/&gt;
描いた世界への旅は〖朝着描绘出的世界走出的旅程〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;やっと青春の始まり　この快感をあげたい〖终于到了青春的开始　想要给予这份快感〗&lt;br/&gt;
どこまでも伸びてゆく誇らしさ〖任何地方都一直在增长的自豪感〗&lt;br/&gt;
やっと青春の始まり　この快感が好きだよ〖终于到了青春的开始　喜欢这份快感〗&lt;br/&gt;
本当に君はいて(素敵さいつも)〖你真的存在(一直都很出彩)〗&lt;br/&gt;
本当の君のため〖为了真正的你〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;&lt;small&gt;きっと青春が聞こえる　その瞬間に聞こえる〖一定能听到青春的音符　就在那个瞬间〗&lt;br/&gt;
笑顔ならいつの日も大丈夫！〖保持微笑的话　每天都能过得愉快〗&lt;br/&gt;
きっと青春が聞こえる　その瞬間が見たいね〖一定能听到青春的音符　想要见证那个瞬间〗&lt;br/&gt;
となりに君がいて(嬉しい景色)〖你就在我身旁(令人高兴的景色)〗&lt;br/&gt;
となりは君なんだ〖我的身旁就是你〗    &lt;/small&gt;&lt;/p&gt;

&lt;p&gt;（附：音频播放支持来源于&lt;a href=&quot;http://kolber.github.io/audiojs/&quot; title=&quot;audio.js&quot;&gt;audio.js&lt;/a&gt;）&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>jQuery使用的最佳实践</title>
   <link href="http://acgtofe.com/posts/2013/04/jquery-best-practice"/>
   <updated>2013-04-03T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/04/jquery-best-practice</id>
   <content type="html">&lt;h2&gt;引言&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;jQuery&lt;/em&gt;可以说是web开发领域应用最为广泛的轻量级javascript库，不仅专业的web开发者使用它，很多刚入门的web开发者或者web爱好者也通过使用jQuery轻松地融入到了javascript的开发。&lt;/p&gt;

&lt;p&gt;而如果你还希望在这方面做得更好，就应学习和了解最佳实践。&lt;em&gt;最佳实践&lt;/em&gt;（&lt;em&gt;Best Practice&lt;/em&gt;）是随某一技术领域的发展而逐渐建立起来的关于最新技术和开发方法的信息，在web开发领域也非常有用。&lt;/p&gt;

&lt;p&gt;本文内容参考了杰出前端工程师 &lt;a href=&quot;http://addyosmani.com/blog/&quot; title=&quot;Addy Osmani&quot;&gt;Addy Osmani&lt;/a&gt; 的 &lt;a href=&quot;https://speakerdeck.com/addyosmani/jquery-performance-tips-tricks&quot; title=&quot;jQuery Performance TIPs &amp;amp; Tricks&quot;&gt;jQuery Performance TIPs &amp;amp; Tricks&lt;/a&gt; ，如果有兴趣，你也可以自己看看这位大师的这个演说PPT，Addy Osmani本人也是jQuery的核心团队（jQuery Core teams）的成员之一。&lt;/p&gt;

&lt;h2&gt;为什么需要遵循jQuery最佳实践&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;web开发领域对于性能的追求是永不停滞的&lt;/em&gt;。jQuery虽然是非常强大的开发工具，但不当的使用方法仍会给浏览器带来额外的工作和负担，也会使开发的web应用占用更多的系统资源，运行起来也更慢。而我们都知道，好的web应用需要的是清爽灵活。&lt;/p&gt;

&lt;p&gt;如何判断javascript的性能呢？现在，这种性能测试都可以归纳为运行速度，简单的说，&lt;em&gt;同一项功能，某一种写法如果比另一种写法运行起来更快，那么这种写法就可以实现更好的性能&lt;/em&gt;。当然，这里只单纯从性能角度来考虑，并不包含代码的可维护性。如果你想自己测试不同的javascript代码段的性能，推荐使用 &lt;a href=&quot;http://jsperf.com/&quot; title=&quot;jsperf.com&quot;&gt;jsPerf.com&lt;/a&gt; ，这个站点可以帮助你轻松创建javascript性能测试用例，还可以保存和分享测试结果。jQuery团队也使用它进行javascript性能测试。&lt;/p&gt;

&lt;h2&gt;jQuery使用建议&lt;/h2&gt;

&lt;h3&gt;1.使用最新版&lt;/h3&gt;

&lt;p&gt;新版本的jQuery提供的API会在性能上有所提升，而且修复了一些存在的bug。由于非常多的网站都在使用jQuery，所以jQuery每一个新版本的更改都会经过非常严格的测试，升级一般都不会带来问题。&lt;/p&gt;

&lt;p&gt;此外，新版本的jQuery可能会在API上做非常有用的改动，让开发工作更加简单。比如在jQuery 1.7之前，事件绑定使用&lt;code&gt;bind()&lt;/code&gt;、&lt;code&gt;delegate()&lt;/code&gt;以及&lt;code&gt;live()&lt;/code&gt;这几个方法。虽然都是事件绑定，但每个方法各有针对，这就产生了“什么时候应该使用哪个”的麻烦事。而从jQuery 1.7开始，新增并推荐使用&lt;code&gt;on()&lt;/code&gt;和&lt;code&gt;off()&lt;/code&gt;这2个方法来完成所有的事件绑定与移除，理解起来就要容易多了。&lt;/p&gt;

&lt;h3&gt;2.理解你的选择符&lt;/h3&gt;

&lt;p&gt;在jQuery中，不是所有的选择符（Selectors）都是同等性能的。也就是说，虽然某一些元素你可以用很多种不同的选择符写法来选取，但不要认为它们在性能上也是一样的。&lt;/p&gt;

&lt;p&gt;jQuery的选择符的运行速度是不同的，从最快到最慢依次是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ID选择符（&lt;code&gt;$(#ElementId)&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;元素选择符（&lt;code&gt;$(form)&lt;/code&gt;，&lt;code&gt;$(input)&lt;/code&gt;等）&lt;/li&gt;
&lt;li&gt;Class选择符（&lt;code&gt;$(.someClass)&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;伪类和属性选择符（&lt;code&gt;$(:hidden)&lt;/code&gt;，&lt;code&gt;$([attribute=value])&lt;/code&gt;等）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;由于浏览器支持的原生DOM操作方法（比如&lt;code&gt;document.getElementById()&lt;/code&gt;）就可用，所以ID选择符和元素选择符是最快的。而稍慢的Class选择符是因为IE6-IE8不支持原生的&lt;code&gt;getElementsByClassName()&lt;/code&gt;，而在支持这个原生方法的其他现代浏览器中，Class选择符仍是很快的。&lt;/p&gt;

&lt;p&gt;至于最慢的伪类和属性选择符，则是因为浏览器并不提供对应功能的可用原生方法。尽管jQuery尝试了使用&lt;code&gt;querySelector()&lt;/code&gt;和&lt;code&gt;querySelectorAll()&lt;/code&gt;这两个原生选择符API（属于css查询API）来提升部分jQuery选择符在部分现代浏览器中的性能，但综合起来，仍然是比较慢的。当然，这也是在于jQuery对伪类和属性选择符这个API要求较高，不仅要支持&lt;code&gt;input[type=&quot;text&quot;]&lt;/code&gt;这种css中合法的选择符，还要支持&lt;code&gt;p:first&lt;/code&gt;这类用于元素过滤，但在css中不合法的选择符。总之，jQuery的伪类和属性选择符功能很强大，但请慎重使用。&lt;/p&gt;

&lt;h3&gt;3.缓存你操作的元素&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;.parents&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;children&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;.parents&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;.child&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//bad&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;缓存是指保存jQuery选择符的返回结果，方便之后再次调用。每一个&lt;code&gt;$('.whatever')&lt;/code&gt;都会重新从DOM中搜索并返回一个jQuery包装集（jQuery collection），因此要避免重复使用。&lt;/p&gt;

&lt;p&gt;原生javascript中，建立局部变量来缓存数据或对象，有利于精简代码、优化性能。这里也是一样的道理。&lt;/p&gt;

&lt;h3&gt;4.链式语法&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;.parents&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;doSomethingElse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;jQuery中大部分方法都返回jQuery包装集并支持这种链式语法。javasript的性能优化要点之一是最小化语句数，因此链式语法不仅写起来更容易，运行起来也会更快。&lt;/p&gt;

&lt;h3&gt;5.使用事件代理&lt;/h3&gt;

&lt;p&gt;利用事件冒泡，指定一个位于dom较高层级的元素（比如&lt;code&gt;document&lt;/code&gt;）的事件处理程序，就可以管理某一类型的所有事件。减少了页面中添加的事件处理程序，自然可以提升整体性能。&lt;/p&gt;

&lt;h3&gt;6.最小化现场更新&lt;/h3&gt;

&lt;p&gt;如果你进行操作的DOM部分是已经显示的页面的一部分，那么你就是在进行一个&lt;em&gt;现场更新&lt;/em&gt;。现场更新需要浏览器重新计算尺寸，涉及到重绘（repaint）和回流（reflow），有较高的性能花费，因此应减少使用。&lt;/p&gt;

&lt;p&gt;在新增内容时，建议先把要新增的代码段合并完全，最后再使用单个&lt;code&gt;append()&lt;/code&gt;方法添加到页面。而如果元素存在复杂的交互，比如反复地添加和移除，&lt;code&gt;detach()&lt;/code&gt;这个针对性的方法就是最佳的选择。&lt;/p&gt;

&lt;h3&gt;7.不在不必要的时候使用jQuery方法&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;.nav_link&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;click&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;nav id: &amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;id&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//bad&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;jQuery方法不一定是最好的方法。这里使用&lt;code&gt;$(this).attr('id')&lt;/code&gt;获取当前事件元素的ID，为当前事件元素创建了jQuery包装集，然后调用&lt;code&gt;attr()&lt;/code&gt;属性获取方法。但这都是额外的性能花费。事实上，&lt;code&gt;this&lt;/code&gt;在事件函数内就表示当前事件元素，直接使用&lt;code&gt;this.id&lt;/code&gt;就可以获取元素ID，这种原生DOM属性的写法要更快。&lt;/p&gt;

&lt;h3&gt;8.适当使用jQuery工具函数&lt;/h3&gt;

&lt;p&gt;操作jQuery包装集的方法（也就是写在&lt;code&gt;$.fn&lt;/code&gt;中的方法），其中一部分也有作为jQuery工具函数（直接写在&lt;code&gt;$&lt;/code&gt;中的方法）的同类方法。由于jQuery工具函数在使用中不涉及创建jQuery包装集，因此，在部分情况下，可以通过换用jQuery工具函数提升性能。&lt;/p&gt;

&lt;p&gt;比如，在DOM中存储数据，一般的做法是：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;#elem&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//common way&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但改为下边的写法会快很多：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//significantly faster&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要的注意的是，虽然下面这种方法更快，但作为参数传入的元素不能用选择符，而要用元素本身。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;我自己整理和写本文内容时，也感觉很有收获。jQuery是一个很强大的工具，但进一步说，也只提供了web开发的最基本的内容，更高级更复杂的内容，还需要自己不断学习和创作。在这个过程中，遵循最佳实践，养成良好的习惯，会有很大的益处，并逐渐做得更出色！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>社会秩序与人类意志的选择—PSYCHO-PASS分析与感想</title>
   <link href="http://acgtofe.com/posts/2013/03/thoughts-of-psycho-pass"/>
   <updated>2013-03-26T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/03/thoughts-of-psycho-pass</id>
   <content type="html">&lt;p&gt;在不久的未来，随着科学的不断进步，人类灵魂的秘密也被揭开，社会也由此发生了革命性的变化。人类的心理状态与性格倾向都可以测量并数值化，所有的心理倾向都被记录和管理，这其中可以成为每个人的灵魂的判定标准的测量数值，被人们称为&lt;em&gt;PHYCHO-PASS&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/psycho_pass_title.jpg&quot; title=&quot;PSYCHO-PASS&quot; alt=&quot;PSYCHO-PASS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;建立在这种心灵测量数值的基础之上的，被称为&lt;em&gt;西比拉系统&lt;/em&gt;（&lt;em&gt;SIBYL SYSTEM&lt;/em&gt;）的社会管理系统，则通过对社会的每一个人的PHYCHO-PASS进行分析和管理，读取每个人的心理的愿望，个体能力及职业适应性，为每一个人给出最适合的生活方式，并以此建立了一个较为理想和稳定的社会。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/mental_color.jpg&quot; title=&quot;色相&quot; alt=&quot;色相&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PHYCHO-PASS的信息的视觉化，反映为&lt;em&gt;色相&lt;/em&gt;，心理状态良好，色相则趋向于白色，心理状态消极，色相则趋于黑色。在色相健康的情况下，PHYCHO-PASS中的信息之一，称为&lt;em&gt;犯罪系数&lt;/em&gt;，会维持在较低的状态。因为某些原因犯罪系数上升，则会被要求接受心理治疗。而当犯罪系数超过指定数值，则会被认定为犯罪者或潜在犯罪者。&lt;/p&gt;

&lt;p&gt;在这个社会，公安局是最为重要的秩序核心。它的刑事科成员，由&lt;em&gt;监视官&lt;/em&gt;和&lt;em&gt;执行官&lt;/em&gt;组成的队伍，则担负着抓捕或处决犯罪者及潜在犯罪者，维护社会治安的重要责任。PHYCHO-PASS的故事由此展开。&lt;/p&gt;

&lt;h2&gt;监视官和执行官&lt;/h2&gt;

&lt;p&gt;大雨，被封锁的案件现场。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“我是即日起被配属到刑事科的常守朱,请多多指教...”&lt;/p&gt;

&lt;p&gt;“抱歉，我们刑事科现在非常缺人，没工夫把你作为新人看待了。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;由此，常守朱成为刑事科一班的第二位监视官，和宜野座伸元监视官一同，带领狡啮慎也、征陆智己、滕秀星和六合冢弥生四位执行官作为刑事科一班执行任务。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;监视官&lt;/em&gt;，如字面意义所示，对执行官进行监控，指挥，并对执行官的行为负责。监视官必须有良好的精神状态，犯罪系数也必须在规定范围内。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/official_logo.png&quot; title=&quot;公安局刑事科&quot; alt=&quot;公安局刑事科&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“接下来将要见的家伙们，可不要当做一样的人类来看待。他们是PSYCHO-PASS的犯罪系数超过规定数值的人格破裂者，他们本应作为潜在罪犯而被隔离，唯一允许他们进行的社会活动，就是抓获同为犯罪者的人。他们是猎犬，是为狩猎野兽而存在的野兽，他们便是执行官。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;执行官&lt;/em&gt;是监视官的下属，必须在监视官的陪同下才可以行动，是执行任务的最前线的人。和作为目标的犯罪者有同样气息的他们，更有能力找到和抓捕犯罪者。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“犯罪或者制止犯罪，无论选择哪条路都需要犯罪的才能。……因此才会有我们这些接脏活的猎犬。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;监视官和执行官使用的警用枪械—&lt;em&gt;Dominator&lt;/em&gt;（&lt;em&gt;支配者&lt;/em&gt;），具有严格的使用者及目标的识别系统，在枪口瞄准的时候即可测得目标的犯罪系数，只有犯罪系数超过指定值的犯罪者或潜在犯罪者，才会解除保险允许射击。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/banner_dominator.jpg&quot; title=&quot;Dominator&quot; alt=&quot;Dominator&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;犯罪认知&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;“犯罪系数，265，确认为执行对象，解除安全限制。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;依靠西比拉系统，案件处理只需要检测犯罪嫌疑人的犯罪系数，就可以断定出犯罪者。此外，在公共区域常设的色相扫描仪，以及巡视的无人机，也会监测每一个人的犯罪系数，随时向公安局报告异常。&lt;/p&gt;

&lt;p&gt;任何人有过涉及犯罪的行为，或者有犯罪倾向，这些原本深藏于人类内心的信息现在却可以被侦测出。基于这种心灵辨识系统，社会拥有了针对犯罪行为的革命性的控制力。&lt;/p&gt;

&lt;p&gt;但是，许多问题的根源也在此。&lt;/p&gt;

&lt;h2&gt;人生设计&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;“能者成能事，这正是西比拉为人类带来的恩惠。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;我们常说，当所有的东西都在正确的位置的时候，一切都可以平稳运行。西比拉系统测定每个人的个体能力，并给出每个人对应的适合的职业。每个人都不必再困惑于做这些选择，西比拉系统针对每个人所给出的答案，就是这个人正确的、会过得快乐的生活方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/banner_city.jpg&quot; title=&quot;城市&quot; alt=&quot;城市&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么，当一切依托于西比拉系统的时候，西比拉系统本身就必须要求&lt;em&gt;完美&lt;/em&gt;。然而，正如自然界的一般规律，西比拉系统也无法做到完美。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“对将来毫无期待的人生，你们这些被系统祝福的人是不会明白的。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;依照西比拉系统的认定，每个人的个体能力都不相同，优秀的人可以有很多机会，可以从事更多更好的工作，而不被系统认可的人则直接被否决了从事许多工作的可能性，无论这些人自身有多么期望做其他的自己想做的工作。这种差别对待让一部分人对系统抱有怨恨，并感慨“神是不公平的“。但是，这也实际上是任何阶级社会都必然存在的问题。&lt;/p&gt;

&lt;h2&gt;人类意志&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;&quot;我啊，认为人们只有在依靠自身意志行动时才拥有价值，所以，我才追寻各种各样的人的潜在想法，并观察他们的行为。&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;西比拉系统的判定在社会总体上为人类带来恩惠的同时，却也忽略了人类的&lt;em&gt;个人意志&lt;/em&gt;。槙岛圣护这位谜一样的男子，策划并诱导了一系列犯罪案件，并希望能通过研究这个社会中的犯罪者们的心理，获取人类意志的秘密，以此肯定人类的存在价值。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“换做是没有西比拉诊断的时代，能不能幸福可是得看运气来的，和以前比起来要好多了吧。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;在这个社会里，当人们面临各种选择的时候，都会倾向于依靠西比拉系统的判定，而无需烦恼于如何做选择。依照西比拉系统的判定去做，自身会过得更幸福，社会也能获得繁荣和稳定。但是，所谓幸福的定义是什么，人生的意义又是什么？在某些人看来，不以自己的个人意志来决定自己的人生，就无法实现幸福和人生意义。自己是应该按照自己所希望的方式活着，还是应该考虑到“为了这个社会好”而遵从社会所希望的自己的方式活着？&lt;/p&gt;

&lt;h2&gt;免罪体质&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;“如果存在能够制裁我的人，那一定是可以凭借自身意志杀人的人。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;免罪体质&lt;/em&gt;，指的是PSYCHO-PASS扫描仪的测量值和犯罪心理并不一致的特殊案例，人数极少，而且这个概念本身是公安局的高层机密。本质而言，是免罪体质者的PSYCHO-PASS无法被西比拉系统解析，因此也就无法被西比拉系统管理，因此也称为特异者。拥有免罪体质的槙岛圣护，自出生起，无论何种情况下，犯罪系数都不会高于指定数值，色相也一直维持纯白的状态。&lt;/p&gt;

&lt;p&gt;免罪体质者永远不会被西比拉系统认定为犯罪者。这些免罪体质者的存在，令人不得不对西比拉系统抱有怀疑和敌意。而槙岛圣护自己，正如狡啮慎也所说，并不把这看做是一种特权，相反，槙岛圣护因为自己无法被西比拉系统解析并纳入社会管理，有着强烈的孤独感，不能被纳入社会，也就是没有被社会承认是“人类”。槙岛圣护决定要研究与目前的社会所不同的，自己以至人类的价值所在。&lt;/p&gt;

&lt;h2&gt;西比拉系统的真相&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;“成为西比拉系统成员的最重要的资格要求是，必须拥有不同于既存人类规范的异常人格，能以非人类的眼光来俯瞰裁定人类的行为。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;随着故事发展，西比拉系统的真相也被揭开。西比拉系统实际上是大量的具有免罪体质的人类大脑的集合体，拥有自己的作为集合体的思想。也就是说，如果西比拉系统是在“统治”着整个社会，那么仍然是“人”在“统治”着整个社会。但西比拉系统自己认为，“他们”早已是超越人类之上的存在，不能再定义为“人类”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/sibyl_system.jpg&quot; title=&quot;西比拉系统&quot; alt=&quot;西比拉系统&quot; /&gt;&lt;/p&gt;

&lt;p&gt;依照西比拉系统自身给出的理论，单纯的改善系统，使系统复杂化，是无法实现完美的。所以，换一个角度考虑，得出的结论就是，将系统无法管理的特异者集合在一起，并从中分析寻求出一种共存的手段，便可以得到管理社会的正确的方法。西比拉系统通过不断的吸纳那些与一般人有明显的差距的拥有崭新思想和价值观的人加入，使自己思考的幅度不断扩张，并由此不断进化。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“理想的官吏，借用马克斯·韦伯的话来说，就是既不会愤怒，也不会不公，既没有憎恨，也没有激情，既没有爱，也不会狂热，自始至终只履行自身义务的人。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;从社会学的角度来说，西比拉系统可以说是法制社会的一种极致。考虑一下法制社会，我们理想的情况是，法律完善，在法律面前，所有人都要平等接受审判，法律规定了什么是正确的，什么是不正确的，什么样的行为是犯罪行为。在法制社会，不容许个人主观认定犯罪。而另一方面，法制社会中的法律终归是由人制定，由人来确保执行力，而且体现的也是多数人所能共同认可的内容。结合西比拉系统这个人类大脑的集合体来说，是不是确实有很多相似的地方？&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“系统这东西，比起让其完美地运行，一直相信其是完美的这一点更加重要。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;法制社会中的法律，是无法完善到能正确处理社会生活的每一个细节的。而类似的西比拉系统，也因为免罪体质者的存在，不能认为是完美的。但是，相比于法律世界的辩护和裁决，西比拉系统“看上去”更像是一个只机械化履行义务的符合理想需要的&lt;em&gt;秩序管理者&lt;/em&gt;。人们相信并依赖西比拉系统，才因此有了目前的繁荣和稳定的社会。&lt;/p&gt;

&lt;h2&gt;终局&lt;/h2&gt;

&lt;p&gt;狡啮慎也与槙岛圣护，最终都以自己的个人意志，结束了两人之间的对决。善与恶，是与非，此时都已不再重要，他们都以行动贯彻了自己所坚持的信念，即使是在这个充满秩序的社会中被认为是错误的道路，他们也决心要走下去。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/members_on.jpg&quot; title=&quot;刑事科一班&quot; alt=&quot;刑事科一班&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一切都结束之后，已经成长为出色可靠的监视官的常守朱，来了西比拉系统的面前。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“不要小看人类，我们无论何时都在追求着更好的社会，总会有一天有人来关掉这个房间的电源，一定会找到崭新的道路给你看。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;作为这个社会基石的西比拉系统依然存在。至少，目前的社会还不能失去西比拉系统。但是，常守朱坚信着一个不一样的未来。&lt;/p&gt;

&lt;p&gt;依然是一场大雨，以及被封锁的案件现场。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;“我是即日起被配属于刑事科的霜月美佳，请多多指教。”&lt;/p&gt;

&lt;p&gt;“抱歉，我们刑事科现在非常缺人，虽然我们会帮助你，但没工夫把你作为新人看待了。”&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;常守朱冷静地回答道。仍然是刑事科一班，但一切却又变得那么不同。常守朱带领下的刑事科一班的故事还将继续。&lt;/p&gt;

&lt;p&gt;进化着的西比拉系统，以及始终追求着更好社会的人类。社会秩序与人类意志的碰撞下，未来究竟又会如何呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（注：PSYCHO-PASS，译为心理测量者，2012年10月番，一共22集，是动画公司Production I.G制作的原创动画）&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>简单实现固定在页面底部的页脚</title>
   <link href="http://acgtofe.com/posts/2013/03/sticky-footer"/>
   <updated>2013-03-13T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/03/sticky-footer</id>
   <content type="html">&lt;h2&gt;页脚的位置问题&lt;/h2&gt;

&lt;p&gt;网页的页脚（footer），也就是通常用来放置帮助链接及版权信息的地方。页脚自然是应该位于页面底部的，但依照一般的做法，如果位于页脚之前的网页内容比较少，或者说使用了一个垂直分辨率较大的显示器，就有可能出现页脚看起来不在页面底部的情况，如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/footer_distance.jpg&quot; title=&quot;页面内容不足的时候，页脚将不能贴到底部&quot; alt=&quot;页脚不能贴到底部&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于页脚基本上是一个网站的所有页面公用的部分，不同页面的内容量有所差异，因此确实有可能某些页面内容不够而出现这样的问题。另外，尤其是包含了底色的页脚，发生这种问题会很影响美观。&lt;/p&gt;

&lt;p&gt;所以，我们希望页脚能够&lt;em&gt;无论网页内容量多少，都准确地位于底部&lt;/em&gt;。&lt;/p&gt;

&lt;h2&gt;固定页脚到底部的方法&lt;/h2&gt;

&lt;h3&gt;绝对定位可行吗？&lt;/h3&gt;

&lt;p&gt;也许有人想到过把页脚设置为&lt;code&gt;position:fixed&lt;/code&gt;，然后定位在底部。先不考虑不支持这个属性值的IE6，从效果上说，如果网页本身内容就很充足，这样的写法就会让页脚一开始就出现在浏览器的底部，而在滚动网页时，页脚会一直保持原位置。这样的效果，显然对大部分的网站都是不适宜的。&lt;/p&gt;

&lt;p&gt;可以想见，我们需要的效果是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网页内容较多时，在滚动到底部的时候才看到位于最下方的页脚。&lt;/li&gt;
&lt;li&gt;网页内容较少时，页脚仍然位于整个页面的最下方，其余部分留白。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;常规、简单的实现方法&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://ryanfait.com/sticky-footer/&quot; title=&quot;A CSS Sticky Footer&quot;&gt;CSS Sticky Footer&lt;/a&gt;提供了这个固定页脚在底部的合理的实现方法。不过一方面这是一个英文站点，另一方面它所提供的写法还存在些许可以改善的地方，所以本文会参考它的内容，给出一个合理的实现方法。&lt;/p&gt;

&lt;p&gt;首先需要这样一个html结构：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;wrapper&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--网页内容--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;footer_placeholder&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;footer&amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--页脚--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;div.wrapper&lt;/code&gt;是网页中除页脚之外的所有内容的外层容器，页脚&lt;code&gt;div.footer&lt;/code&gt;和它位于同一层级。&lt;code&gt;div.footer_placeholder&lt;/code&gt;必须放在网页所有内容的最后，即作为&lt;code&gt;div.wrapper&lt;/code&gt;的最后一个子元素，它的作用会在后文中说明。&lt;/p&gt;

&lt;p&gt;接下来写css，依次做说明。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当网页内容不足的时候，&lt;code&gt;body&lt;/code&gt;和&lt;code&gt;html&lt;/code&gt;的实际高度可能小于浏览器的可视范围，因此给&lt;code&gt;body&lt;/code&gt;和&lt;code&gt;html&lt;/code&gt;写上高度100%。此外，接下来的直接子元素也会使用百分比的写法，百分比的写法必须在直接父元素有确定的高度定义时才有效。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nc&quot;&gt;.wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;min-height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;margin-bottom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;/*假定页脚的高度为120px*/&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所有网页内容都在这个&lt;code&gt;div.wrapper&lt;/code&gt;中，定义最小高度（IE6使用hack），由于这个元素的父元素就是定义了100%高度的&lt;code&gt;body&lt;/code&gt;，因此无论内容多少，&lt;code&gt;div.wrapper&lt;/code&gt;这个元素的高度都会占据整个浏览器可视范围。然后，依照页脚的高度，设置相等的下边距负值，这样页脚就会恰好出现在页面内容的最后。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nc&quot;&gt;.footer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.footer_placeholder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;/*假定页脚的高度为120px*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;div.footer_placeholder&lt;/code&gt;，如字面意义，页脚的占位元素，它只是一个空的&lt;code&gt;div&lt;/code&gt;，定义高度和页脚相同，它的存在是为了给页脚留下位置。如果没有它，可能会发生这样的事情↓&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/footer_placeholder.jpg&quot; title=&quot;页脚占位符的作用&quot; alt=&quot;页脚占位符的作用&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到这里，&lt;em&gt;固定在底部的页脚就已经实现了&lt;/em&gt;。css部分合起来是：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;.wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;min-height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;margin-bottom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;/*假定页脚的高度为120px*/&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;.footer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.footer_placeholder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;120px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果还需要考虑css初始化和清理浮动，可能你还需要添加下面这部分css：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;margin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;.footer_placeholder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;both&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你现在正在看的本博客，就使用了本文的方法，以保证无论内容多少，页脚都能位于页面底部。我也觉得这是一个非常实用的方法！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>acgtofe博客建设完结纪念</title>
   <link href="http://acgtofe.com/posts/2013/03/acgtofe-complete"/>
   <updated>2013-03-12T00:00:00+08:00</updated>
   <id>http://acgtofe.com/posts/2013/03/acgtofe-complete</id>
   <content type="html">&lt;p&gt;到写下这段文字时，本博客也宣布初步完工。&lt;/p&gt;

&lt;p&gt;本博客的名字是acgtofe，如简介介绍的那样，我会在这里发布有关动漫、游戏、前端技术的博文，你也许看到了demo pages，这是我最开始构思博客的时候觉得可以加入的内容，字面意思理解的话，就是指实例，不过之后具体会是什么，我还在思考中，所以敬请期待。这也是为什么只说本博客是初步完工。&lt;/p&gt;

&lt;p&gt;说起来，把动漫和前端技术结合起来放在一起，还拼凑了这么一个名字，真是预想不到呢。ACG已经是一个很多人都知道的词了，而这个to虽然我是想说就是表示什么“和”什么，不过现在看来，单纯理解为英文介词to也不错...而FE所指的前端开发（Frond-End），相对来说就很少会有人知道了。这也难免，前端开发一词用作职业描述，已经算是比较新的事了。我自己则是前一段时间看国外的博文，偶然看到了这个词，然后查询了一下，才知道这个意思。有没有觉得，中文的翻译特别的直接？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/used-images/posts/201303/bookmark_start.jpg&quot; title=&quot;acgtofe博客建设完结纪念&quot; alt=&quot;acgtofe博客建设完结纪念&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“爱好ACG并从事web前端工作”，参考这样的描述，所以我做了这样的一个博客。希望本博客的内容，无论是对作为ACG同好的你，还是在从事前端工作的你，都能带来一些有用的信息，或者是有学习价值的知识，也或者是一点点的生活乐趣。&lt;/p&gt;

&lt;p&gt;本博客通过&lt;a href=&quot;http://jekyllbootstrap.com/&quot; title=&quot;Jekyll Bootstrap&quot;&gt;Jekyll Bootstrap&lt;/a&gt;搭建，如果你也对做这样的一个博客有兴趣，可以自己搜索相关的介绍信息及教程。&lt;/p&gt;

&lt;p&gt;博客建设完结，撒花！&lt;/p&gt;
</content>
 </entry>
 
 
</feed>